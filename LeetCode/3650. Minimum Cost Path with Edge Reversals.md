---
tags:
  - LeetCode
---

# [3650. Minimum Cost Path with Edge Reversals](https://leetcode.com/problems/minimum-cost-path-with-edge-reversals/description/)  

+ 日期 : 2026/01/27  

## 問題描述  

寫得狠醜但我過了，爽啦  

## 直覺想法  

## 題解  

```cpp=
class cmp {
public:
    bool operator()(vector<int> &a, vector<int> &b) {
        return abs(a[0]) > abs(b[0]);
    }
};
class Solution {
public:
    int minCost(int n, vector<vector<int>>& edges) {
        vector<int> dist(n, INT_MAX);
        dist[0] = 0;
        unordered_map<int, unordered_map<int, int>> adj;
        for(vector<int> e : edges) {
            int u = e[0];
            int v = e[1];
            int c = e[2];
            adj[u][v] = (adj[u].count(v)) ? adj[u][v] : 1e6;
            adj[v][u] = (adj[v].count(u)) ? adj[v][u] : 1e6;

            adj[u][v] = min(abs(adj[u][v]), c);
            if(abs(adj[v][u]) > abs(-2 * c))
                adj[v][u] = -2 * c;
        }

        // [cost, node]
        priority_queue<vector<int>, vector<vector<int>>, cmp> pq;
        pq.push({0, 0});
        while(!pq.empty()) {
            vector<int> top = pq.top();
            pq.pop();
            int c = top[0];
            int node = top[1];

            if(c > dist[node])  continue;
            for(auto [nei, cost] : adj[node]) {
                if(cost > 0) {
                    if(dist[nei] > c + cost) {
                        dist[nei] = c + cost;
                        pq.push({c + cost, nei});
                    }
                } else {
                    if(dist[nei] > c - cost) {
                        dist[nei] = c - cost;
                        pq.push({c - cost, nei});
                    }
                }
            }
        }
        return (dist[n-1] == INT_MAX) ? -1 : dist[n-1];
    }
};
```

Time Complexity : $O(eloge)$  
Space Complexity : $O(e + v)$  

## 心得  

舒服  
