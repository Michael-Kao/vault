---
tags:
  - LeetCode
---

# [2044. Count Number of Maximum Bitwise-OR Subsets](https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/description/)  

+ 日期 : 2025/07/28  

## 問題描述  

給定一個數字陣列 `nums`，用 `OR` 運算找出整個陣列中所有值 `OR` 過的結果，  
找出所有子陣列的數量，其中子陣列的 `OR` 運算結果等於整個陣列的 `OR` 運算結果。  

## 直覺想法  

1. 先找出所有 `OR` 運算的結果  
2. 利用 `backtracking`，每個元素可以選和不選  
3. 當陣列走完後，`curr == target`，表示目前的選擇符合條件，則計數加一  

## 題解  

```cpp=
class Solution {
public:
    int countMaxOrSubsets(vector<int>& nums) {
        int n = nums.size();
        int maxOR = 0;
        for(int num : nums) {
            maxOR |= num;
        }
        return helper(nums, maxOR, 0, 0);
    }

    int helper(vector<int> &nums, int &target, int curr, int idx) {
        int n = nums.size();
        if(idx == n)
            return (curr == target) ? 1 : 0;
        
        int res = helper(nums, target, curr, idx+1);
        curr |= nums[idx];
        res += helper(nums, target, curr, idx+1);

        return res;
    }
};
```

Time Complexity : $O(2^n)$  
Space Complexity : $O(n)$  

## 心得  

今天竟然在 `backtracking` 上卡住了，到底在幹嘛阿...
