---
tags:
  - LeetCode
---

# [84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/description/)  

+ 日期 : 2025/09/06  

## 問題描述  

給定一組整數陣列 `heights`，代表直方圖中每個長條的高度，  
請找出能夠形成的最大矩形面積。每個長條的寬度為 1。

## 直覺想法  

首先要知道，我們是從左側陣列開始往右側掃描，因此可以假設我們有左側的資訊，  
具體要怎麼儲存跟使用先不考慮，那麼回到問題，假設目前高度是 `[2, 4]`，且位置在 `4`，  
那麼對 `4` 而言，可以組成 `4*1` 的矩形，`2` 則是 `2*2`，意思是以當前位置為終點，計算左側可能的矩形，  
如果今天高度為 `[2, 1]`，當位置在 `1` 時，可以發現 `2` 並不能往右延伸了，若要保留高度為 `2`，  
那麼他的最大矩形只能是 `2*1`，即 `2*(idx_1 - idx_0)` ，由於 `2` 不能延伸，所以我們結算 `2` 能組成的最大矩形，  
此外高度 `1` 不只可以向右延伸，還可以向左，原因在於對於高度 `1` 而言，在此左側比高度 `1` 高的矩陣都計算完成了，  
剩下的都就是高度 `1` 可以延伸到的位置，總結如下：  

1. 從左往右看陣列  
2. 如果目前高度較左側高，儲存後繼續往右，原因在於左側高度低的依舊可以向右延伸  
3. 如果目前高度較左側低，則左側高度無法再向右延伸，結算左側高度能組成的最大矩形，並且將目前高度加入儲存結構中  

步驟三的目的在於將過高的部分剷平，因為這些高度無法再向右延伸了，  
要儲存這樣的內容，可以使用 `stack`，並且 `stack` 又會根據情況，數值只會越來越大，  
又稱為 `monotonic stack`。  

## 題解  

```cpp=
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        stack<pair<int, int>> stk; // [hight, idx]
        stk.push({heights[0], 0});
        int res = 0;
        for(int i = 1; i < n; ++i) {
            int pos = i;
            while(!stk.empty() && stk.top().first > heights[i]) {
                auto [hei, idx] = stk.top();
                stk.pop();
                int width = i - idx;
                pos = idx;
                res = max(res, hei * width);
            }
            stk.push({heights[i], pos});
        }
        while(!stk.empty()) {
            auto [hei, idx] = stk.top();
            stk.pop();
            int width = n - idx;
            res = max(res, hei * width);
        }
        return res;
    }
};
```

Time Complexity : $O(n)$  
Space Complexity : $O(n)$  

## 心得  

說實話這題我寫過三次，應該每次都寫不出來，未來如果面試遇到應該也是不會吧...  
坦白說我對想出解法的過程沒有什麼概念，答案看得懂，但怎麼推導卻不知道，  
原本開始寫題解就是用來釐清思路的，但感覺根本沒有進展，至少這第一次寫過題解了，  
希望下次遇到能修改的更容易懂。  
