---
tags:
  - LeetCode
---

# [3508. Implement Router](https://leetcode.com/problems/implement-router/description/)  

+ 日期 : 2025/09/20  

## 問題描述  

實作一個資料結構 Router，支援以下方法：  

1. `Router(int memoryLimit)`: 初始化 Router，並設定記憶體限制為 `memoryLimit`。  
2. `bool addPacket(int source, int destination, int timestamp)`: 嘗試新增一個封包，來源為 `source`，目的地為 `destination`，時間戳為 `timestamp`。  
    + 同樣的風暴封包（相同的 `source`、`destination`、`timestamp`）只能加入一次  
    + 如果新增封包會導致記憶體超過限制，則移除最舊的封包  
    + 如果成功新增封包，回傳 `true`，否則回傳 `false`  
3. `int[] forwardPacket()`: 嘗試轉發最舊的封包，並將其從 Router 中移除。  
    + 如果有封包可轉發，回傳一個陣列 `[source, destination, timestamp]`，否則回傳空陣列 `[]`。  
4. `int getCount(int destination, int startTime, int endTime)`: 回傳在時間區間 `[startTime, endTime]` 內，目的地為 `destination` 且還在 `Router` 中的封包數量。  

## 直覺想法  

+ [Discussion](https://leetcode.com/problems/implement-router/solutions/6620477/hashmap-queue-step-by-step-c-python-java)  

記錄下本題需要學起來的重點:  

+ 嘗試用多個 `Hash Map` 來紀錄不同的資訊，每個 `Hash Map` 越單純越好  
+ `int getCount()` 中使用 `ptr` 作為 `arr` 而不是直接複製一個完整的 `arr`，可以節省空間  
+ `lower_bound` 和 `upper_bound` 的使用  

## 題解  

```cpp=
class Router {
public:
    int memory;
    queue<vector<int>> q;
    set<vector<int>> mp; // {s,d,t}
    unordered_map<int, vector<int>> ts; // dst->times
    unordered_map<int, int> finish; // dst->finish_cnt
    Router(int memoryLimit) 
        : memory(memoryLimit) {
    }
    
    bool addPacket(int source, int destination, int timestamp) {
        vector<int> cur = {source, destination, timestamp};
        if(mp.count(cur))
            return false;
        if(q.size() == memory) {
            vector<int> tmp = q.front();
            mp.erase(tmp);
            finish[tmp[1]] += 1;
            q.pop();
        }
        q.push(cur);
        mp.insert(cur);
        ts[destination].push_back(timestamp);
        return true;
    }
    
    vector<int> forwardPacket() {
        if(q.empty())   return {};
        vector<int> res = q.front();
        q.pop();
        mp.erase(res);
        finish[res[1]] += 1;
        return res;
    }
    
    int getCount(int destination, int startTime, int endTime) {
        if(!ts.count(destination))  return 0;
        auto &ptr = ts[destination];
        int start = finish[destination];
        auto right = lower_bound(ptr.begin() + start, ptr.end(), startTime);
        auto left = upper_bound(ptr.begin() + start, ptr.end(), endTime);
        return int(left - right);
    }
};

/**
 * Your Router object will be instantiated and called as such:
 * Router* obj = new Router(memoryLimit);
 * bool param_1 = obj->addPacket(source,destination,timestamp);
 * vector<int> param_2 = obj->forwardPacket();
 * int param_3 = obj->getCount(destination,startTime,endTime);
 */
```

Time Complexity : $O(nlogn)$  
Space Complexity : $O(n)$  

## 心得  

精疲力竭，個人認為 `ptr` 那部份今天有學到就值得了，`Hash Map` 的感覺應該只能多寫來練了吧  
