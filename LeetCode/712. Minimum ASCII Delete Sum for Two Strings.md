---
tags:
  - LeetCode
---

# [712. Minimum ASCII Delete Sum for Two Strings](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/description/)  

+ 日期 : 2026/01/10  

## 問題描述  

給兩個字串 `s1` 和 `s2`，找出 ASCII 最小的最長相同子字串  

## 直覺想法  

1. 比對兩個字串，若當前字元相同，則兩者 `index` 都往前  
2. 如果不相同，則有兩種選擇，選擇 `s1`，表示 `s1_idx + 1, s2_idx` 的子問題加上當前 `s1[idx]` 為所需要刪除的值  
3. 選擇 `s2`，表示 `s1_idx, s2_idx + 1` 的子問題加上當前 `s2[idx]` 為所需要刪除的值  
4. 選擇兩者的最小值  
5. 直到其中一方 `index` 與字串相符，表示另一個字串剩餘的字元都需要刪除  

## 題解  

```cpp=
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int n = s1.size();
        int m = s2.size();
        vector<vector<int>> memo(n, vector<int>(m, -1));
        return helper(s1, s2, 0, 0, memo);
    }

    int helper(string &a, string &b, int i, int j, vector<vector<int>> &memo) {
        int n = a.size();
        int m = b.size();
        if(i == n && j == m)    return 0;

        if(i == n || j == m) {
            return (i == n) ? adder(b, j) : adder(a, i);
        }

        if(memo[i][j] != -1)    return memo[i][j];

        int res = 0;
        if(a[i] == b[j])    
            res = helper(a, b, i+1, j+1, memo);
        else {
            res = min(
                helper(a, b, i+1, j, memo) + int(a[i]),
                helper(a, b, i, j+1, memo) + int(b[j])
            );
        }

        return memo[i][j] = res;
    }

    int adder(string &s, int idx) {
        int sum = 0;
        for(; idx < s.size(); ++idx) {
            sum += int(s[idx]);
        }
        return sum;
    }
};
```

Time Complexity : $O(mn)$  
Space Complexity : $O(mn)$  

## 心得  

I said I don't know how to code DP.  
This shit is hard to understand.  
