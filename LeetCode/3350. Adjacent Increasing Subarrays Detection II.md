---
tags:
  - LeetCode
---

# [3350. Adjacent Increasing Subarrays Detection II](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-ii/description/)  

+ 日期 : 2025/10/15  

## 問題描述  

給定一個數字陣列 `nums`，找出該陣列中的子陣列，  
其中子陣列必須嚴格遞增，並且兩個子陣列必須連續，  
問符合上述規則的情況下，該子陣列的最大長度為何？  

## 直覺想法  

走訪陣列的時候必須時刻觀察當前數值是否大於前一個數值，情況如下:  

1. 當前數值大於前一個數值:  
    + 子陣列長度 `+1`  
2. 當前數值小於或等於前一個數值:  
    + 先前的子陣列長度一分為二，硬湊成兩個子陣列  
    + 當前身為一個斷點，以目前位置為起點，往後產生第二個符合條件的子陣列  

由上可知，我們需要一個 `count` 來記錄目前子陣列的長度，  
以及一個 `previous` 來紀錄斷點前的子陣列長度，兩種可能。  

## 題解  

```cpp=
class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int res = 0;
        int cnt = 1;
        int pre = 0;
        for(int i = 1; i < n; ++i) {
            if(nums[i] <= nums[i-1]) {
                res = max(res, cnt / 2);
                res = max(res, min(cnt, pre));
                pre = cnt;
                cnt = 1;
            } else {
                cnt += 1;
            }
        }
        res = max(res, cnt / 2);
        res = max(res, min(cnt, pre));
        return res;
    }
};
```

Time Complexity : $O(n)$  
Space Complexity : $O(1)$  

## 心得  

這是難得我寫的跟答案幾乎一樣的題目，還算好玩  
