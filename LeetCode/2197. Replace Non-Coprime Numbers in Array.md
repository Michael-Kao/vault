---
tags:
  - LeetCode
---

# [2197. Replace Non-Coprime Numbers in Array](https://leetcode.com/problems/replace-non-coprime-numbers-in-array/description/)  

+ 日期 : 2025/09/16  

## 問題描述  

給定一個數字陣列 `nums`，請取出相鄰兩個數字，  
若相鄰兩數的最大公因數 (GCD) 不為 `1`，那麼將兩數合併為兩數的最小公倍數 (LCM)，  
重複以上操作直到陣列中所有相鄰兩數的 GCD 都為 `1` 為止。  

## 直覺想法  

1. 使用 `stack` 可以紀錄目前陣列中的數字，若當下與前項符合，則 `pop`  
2. 若兩數需要合併，則計算 `LCM`，為了找出是否符合，需計算 `GCD`  
3. 實作 `LCM` 與 `GCD` 函式  

+ [GCD & LCM from Jserv](https://hackmd.io/@sysprog/gcd-impl)  

## 題解  

```cpp=
class Solution {
public:
    vector<int> replaceNonCoprimes(vector<int>& nums) {
        int n = nums.size();
        stack<int> stk;
        for(int i = 0; i < n; ++i) {
            int curr = nums[i];
            while(!stk.empty() && gcd(curr, stk.top()) != 1) {
                int a = stk.top();
                stk.pop();
                curr = lcm(a, curr);
            }
            stk.push(curr);
        }
        vector<int> res;
        while(!stk.empty()) {
            int top = stk.top();
            stk.pop();
            res.push_back(top);
        }
        reverse(res.begin(), res.end());
        return res;
    }
    
    int gcd(int a, int b) {
        return a ? gcd(b % a, a) : b;
    }
    
    int lcm(int a, int b) {
        return 1ll * a * b / gcd(a, b);
    }
};
```

Time Complexity : $O(nlogn)$  
Space Complexity : $O(n)$  

## 心得  

這題是 `Gate Keep by GCD & LCM`，沒去找 `GCD` 與 `LCM` 的話我也不會寫==  
話說這種東西是應該要能馬上反應的嗎？  
