---
tags:
  - LeetCode
---

# [3652. Best Time to Buy and Sell Stock using Strategy](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-using-strategy/description/)  

+ 日期 : 2025/12/18  

## 問題描述  

給兩個等長數字陣列 `prices` 和 `strategy`，每組可產生價值為 `prices[i] + strategy[i]`，  
此外還提供一個整數 `k`，代表可以將連續的子陣列中，前 `k/2` 個元素的 `strategy` 值設為 `0`，  
後 `k/2` 個元素的 `strategy` 值設為 `1`，問最大獲利為何  

## 直覺想法  

1. 先計算 `prefix[i] = prices[i] * strategy[i]`  
2. 建立一個 `two pointer` 區間，長度為 `k`，重新計算該區間的產值  
3. 而在此區間的左側值為 `prefix[left-1]`，右側則為 `prefix[n-1]-prefix[right]`  
4. 求出最大值  

## 題解  

```cpp=
class Solution {
public:
    long long maxProfit(vector<int>& prices, vector<int>& strategy, int k) {
        int n = prices.size();
        vector<long long> prefix(n, 0);
        long long res = 0;
        for(int i = 0; i < n; ++i) {
            res += 1ll * prices[i] * strategy[i];
            prefix[i] = res;
        }
        int left = 0;
        int right = 0;
        int mid = k / 2;
        long long cur = 0;
        while(right < n) {
            if(right >= mid) {
                cur += prices[right];
            } 
            if(right - left + 1 > k) {
                cur -= prices[mid];
                mid += 1;
                left += 1;
            }
            if(right - left + 1 == k) {
                long long l = (left == 0) ? 0 : prefix[left-1];
                long long r = prefix[n-1] - prefix[right];
                res = max(res, l + cur + r);
            }
            right += 1;
        }
        return res;
    }
};
```

Time Complexity : $O(n)$  
Space Complexity : $O(n)$  

## 心得  

Waste of my time  
