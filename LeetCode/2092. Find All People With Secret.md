---
tags:
  - LeetCode
---

# [2092. Find All People With Secret](https://leetcode.com/problems/find-all-people-with-secret/description/)  

+ 日期 : 2025/12/19  

## 問題描述  

給定整數 `n` 表示有 `[0, n-1]` 個人，以及一個二維陣列 `meetings`，其中 `meetings[i]=[x, y, time]`，  
表示在 `time` 當下，`x` 和 `y` 有會面，此外還有一個整數 `firstPerson`，  
最初始時，`0` 持有秘密，並且在開始前會與 `firstPerson` 分享，知道秘密的人，在會面的當下會與其他人分享秘密，  
問最後知道秘密的人有哪些？  

## 直覺想法  

1. 先根據時間排序 `meetings` 陣列  
2. 針對排序過的 `meetings`，對於每個 `time` 建立 `Connected Component`  
3. 從時間小開始，將知道秘密的人存起來，並且遍歷該時間內，知道秘密之人的 `Connected Component`  
4. 透過 `DFS` 走訪圖，將與知道秘密會面的人也加入知道秘密的人中  
5. 重複上述步驟直到所有 `meetings` 都處理完畢  

## 題解  

```cpp=
class Solution {
public:
    std::vector<int> findAllPeople(int n, std::vector<std::vector<int>>& meetings, int firstPerson) {
        // mlogm
        sort(meetings.begin(), meetings.end(), cmp());
        unordered_set<int> secret({0, firstPerson});
        map<int, unordered_map<int, vector<int>>> time2graph;
        // m
        for(int i = 0; i < meetings.size(); ++i) {
            int x = meetings[i][0];
            int y = meetings[i][1];
            int time = meetings[i][2];
            time2graph[time][x].push_back(y);
            time2graph[time][y].push_back(x);
        }

        // m * (n + m)
        for(auto it = time2graph.begin(); it != time2graph.end(); ++it) {
            // queue<int> q;
            unordered_set<int> visited;
            unordered_map<int, vector<int>> graph = it->second;
            for(auto [key, val] : graph) {
                if(secret.count(key))
                    dfs(key, graph, visited, secret);
                    // q.push(key);
            }

            // while(!q.empty()) {
            //     int cur = q.front();
            //     q.pop();
            //     secret.insert(cur);
            //     for(int neighbor : graph[cur]) {
            //         if(!secret.count(neighbor)) {
            //             secret.insert(neighbor);
            //             q.push(neighbor);
            //         }
            //     }
            // }
        }
        return vector<int>(secret.begin(), secret.end());
    }

    void dfs(int src, unordered_map<int, vector<int>> &graph, unordered_set<int> &visited, unordered_set<int> &secret) {
        if(visited.count(src))
            return;
        visited.insert(src);
        secret.insert(src);
        for(int neighbor : graph[src]) {
            dfs(neighbor, graph, visited, secret);
        }
    }

    struct cmp {
        bool operator() (const vector<int> &lhs, const vector<int> &rhs) {
            return lhs[2] < rhs[2];
        }
    };
};
```

Time Complexity : $O(m * (n + m))$  
Space Complexity : $O(n + m)$  

## 心得  

I'm so tired.  
