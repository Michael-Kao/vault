---
tags:
  - LeetCode
---

# [3347. Maximum Frequency of an Element After Performing Operations II](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/description/)  

+ 日期 : 2025/10/22  

## 問題描述  

和 [[LeetCode/3346. Maximum Frequency of an Element After Performing Operations I.md]] 相同，  
差異在 `0 <= k <= 10^9`  

## 直覺想法  

這次 `k` 的範圍擴大，導致前一次對所有可能解計算頻率的做法不可行，  
會造成 `MLE`，為了解決這個問題，就必須減少不必要的計算，  
根據數學的推導，我看不懂的東西，只要將 `nums[i] - k` 加入到搜尋的陣列中即可，  
這樣就能包含到所有可能的解。  

## 題解  

```cpp=
class Solution {
public:
    int maxFrequency(vector<int>& nums, int k, int numOperations) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        unordered_map<int, int> cnt;
        set<long long> m_set;
        for(int num : nums) {
            cnt[num] += 1;
            m_set.insert(1ll*num-k);
            m_set.insert(1ll*num);
            m_set.insert(1ll*num+k);
        }
        vector<long long> arr(m_set.begin(), m_set.end());
        int res = 0;
        for(int i = 0; i < arr.size(); ++i) {
            int l = BSL(nums, arr[i], k);
            int r = BSR(nums, arr[i], k);
            int cur = min(r - l + 1, cnt[arr[i]] + numOperations);
            res = max(res, cur);
        }
        return res;
    }
    
    int BSL(vector<int> &nums, long long target, int k) {
        int left = 0;
        int right = nums.size()-1;
        int res = -1;
        while(left <= right) {
            int mid = (right - left) / 2 + left;
            if(1ll * nums[mid] + k >= target) {
                res = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return res;
    }

    int BSR(vector<int> &nums, long long target, int k) {
        int left = 0;
        int right = nums.size()-1;
        int res = -1;
        while(left <= right) {
            int mid = (right - left) / 2 + left;
            if(nums[mid] - k <= target) {
                res = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return res;
    }
};
```

Time Complexity : $O(nlogn)$  
Space Complexity : $O(n)$  

## 心得  

還要數學推導就有點多了，至少我是不會啦，  
現階段也沒有剛需，自然跳過了  
