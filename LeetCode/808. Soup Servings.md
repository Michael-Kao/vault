---
tags:
  - LeetCode
---

# [808. Soup Servings](https://leetcode.com/problems/soup-servings/description/)  

+ 日期 : 2025/08/08  

## 問題描述  

給定一個整數 `n`，假設有 `a` 和 `b` 兩碗湯，分別有 `n` 毫升，  
總共有 `4` 種操作： 

1. 從 `a` 中取出 `100` 毫升，從 `b` 中取出 `0` 毫升。  
2. 從 `a` 中取出 `75` 毫升，從 `b` 中取出 `25` 毫升。  
3. 從 `a` 中取出 `50` 毫升，從 `b` 中取出 `50` 毫升。  
4. 從 `a` 中取出 `25` 毫升，從 `b` 中取出 `75` 毫升。  

每種操作的概率均為 `1/4`，問 `a` 的湯先被喝完的機率 加上 `a` 和 `b` 的湯同時被喝完的機率的一半，  
其總和是多少。  

## 直覺想法  

總共有三種狀況：  

1. `a <= 0 && b > 0` -> 比重為 `1`  
2. `a > 0 && b <= 0` -> 比重為 `0`  
3. `a <= 0 && b <= 0` -> 比重為 `1/2`  

每次都有可能走 `4` 種路徑，每一步都是 `1/4` 的機率，  
所以可以用 `DFS + memoization` 來解，  
但有病的地方在於 `n` 上限為 `10^5`，  
題解有證明當 `n` 大於等於 `4800` 時，其結果為 `1`。  

## 題解  

```cpp=
class Solution {
public:
    double soupServings(int n) {
        if(n >= 4800)   return 1;
        vector<vector<double>> memo(n+1, vector<double>(n+1, -1));
        return calc(n, n, memo);
    }

    double calc(int a, int b, vector<vector<double>> &memo) {
        if((a == b && a <= 0) || (a <= 0 && b <= 0))  return 0.5;
        if(b <= 0)  return 0;
        if(a <= 0)  return 1;
        if(memo[a][b] >= 0)
            return memo[a][b];

        double res = 0.25;
        res *= (
            calc(a - 100, b, memo) + 
            calc(a - 75, b - 25, memo) + 
            calc(a - 50, b - 50, memo) + 
            calc(a - 25, b - 75, memo)
        );
        memo[a][b] = res;

        return res;
    }
};
```

Time Complexity : $O(n)$  
Space Complexity : $O(n^2)$  

## 心得  

這題下次看到肯定不會==  
而且我根本懶得看證明，然後這題 G 出過，有啥病==  
