---
tags:
  - LeetCode
---

# [1792. Maximum Average Pass Ratio](https://leetcode.com/problems/maximum-average-pass-ratio/description/)  

+ 日期 : 2025/09/01  

## 問題描述  

給定一組二維陣列 `classes`，每個 `class = [pass, total]`，此外還有一個整數 `extraStudents`，  
班級通過率的計算方式為 `pass/total`，現在有 `extraStudents` 個學生可以分配到這些班級中，  
每個 `extraStudents` 必定通過，請問分配這些學生後，班級通過率的最大值為何？  

## 直覺想法  

這題是很漂亮的 `Greedy` 題目，你肯定在想，我要怎麼選擇班級來分配學生？  
你唯一的線索就是要讓分配後的通過率最大化，而你能計算的只有當前每個班級的通過率，  
以及當前班級被分配一名學生後的通過率，這兩個數字的差距。  
而這就是所謂的 `Greedy` 演算法，你必須把每次的選擇都做出最好的決定，  
在選擇最大值上，可以使用 `Max Heap` 來達成。  

## 題解  

```cpp=
class Solution {
public:
    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {
        priority_queue<pair<double, int>> maxHeap; // [ratio, index]
        int n = classes.size();
        for(int i = 0; i < n; ++i) {
            double ratio = (double)1 * (classes[i][0] + 1) / (classes[i][1] + 1);
            ratio -= (double)1 * classes[i][0] / classes[i][1];
            maxHeap.push({ratio, i});
        }
        for(int i = 0; i < extraStudents; ++i) {
            auto [_, idx] = maxHeap.top();
            maxHeap.pop();
            classes[idx][0] += 1;
            classes[idx][1] += 1;
            double ratio = (double)1 * (classes[idx][0] + 1) / (classes[idx][1] + 1);
            ratio -= (double)1 * classes[idx][0] / classes[idx][1];
            maxHeap.push({ratio, idx});
        }
        double res = 0;
        for(int i = 0; i < n; ++i) {
            res += (double)1 * classes[i][0] / classes[i][1];
        }
        return res / n;
    }
};
```

Time Complexity : $O(mlogn + n)$  
Space Complexity : $O(n)$  

## 心得  

這題看到提示前根本不知道怎麼解，因為不知道怎麼選擇班級來分配學生，  
而事實卻擺在眼前，真的只要逐步去算當前跟分配一個之後的差距，然後分配完所有學生後再算平均值即可。  
