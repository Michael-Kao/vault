---
tags:
  - LeetCode
---

# [2654. Minimum Number of Operations to Make All Array Elements Equal to 1](https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/description/)  

+ 日期 : 2025/11/12  

## 問題描述  

給定一個數字陣列 `nums`，每次操作可以選擇相鄰的兩個元素，取其 `GCD` 後替換其中一個元素，  
問最少需要多少次操作，能將陣列中所有元素變成 `1`，若無法達成則回傳 `-1`。  

## 直覺想法  

首先至少要觀察出如果陣列有 `1`，那麼剩下的元素都可以透過 `GCD` 操作變成 `1`，  
因此目標找出透過 `GCD` 找出 `1`，且該 `GCD` 操作次數最少，此外 `GCD` 的特性如下，  
`GCD(a, b) = c`，則 `GCD(c, d) = GCD(a, b, d)`，可透過此特性，找出從 `index i` 為起點，  
長度為 `k` 的子陣列能湊出 `1`，將 `k` 找出最小即可找到最少操作次數。  

1. 遍歷陣列從 `0 ~ n-1`  
2. 計算以 `i` 為起點，`GCD` 結果為 `1` 的子陣列長度，更新最小長度  
3. 若結果為 `INT_MAX`，則回傳 `-1`，否則回傳 `minCnt + n - 1 - oneCnt`，其中 `oneCnt` 為陣列中 `1` 的數量  

## 題解  

```cpp=
class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int minCnt = INT_MAX;
        int oneCnt = 0;
        for(int i = 0; i < n; ++i) {
            int pre = nums[i];
            oneCnt += (nums[i] == 1) ? 1 : 0;
            int cnt = 0;
            for(int j = i + 1; j < n; ++j) {
                int nxt = gcd(pre, nums[j]);
                cnt += 1;
                if(nxt == 1) {
                    minCnt = min(minCnt, cnt);
                    break;
                }
                pre = nxt;
            }
        }
        return minCnt == INT_MAX ? -1 : minCnt + n-1 - oneCnt;
    }
    
    int gcd(int a, int b) {
        if(b)
            while((a %= b) && (b %= a));
        return a + b;
    }
};
```

+ `M` is `GCD` time  

Time Complexity : $O(n^logM)$  
Space Complexity : $O(1)$  

## 心得  

現在題目不看 `Hint` 都不會寫了怎麼辦QQ  
