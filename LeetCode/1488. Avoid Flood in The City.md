---
tags:
  - LeetCode
---

# [1488. Avoid Flood in The City](https://leetcode.com/problems/avoid-flood-in-the-city/description/)  

+ 日期 : 2025/10/07  

## 問題描述  

給定一個數字陣列 `rains`，其中 `rains[i] > 0` 表示第 `i` 天在 `rains[i]` 處下雨，  
`rains[i] == 0` 表示第 `i` 天沒有下雨，可以選擇在某個地方放水。
如果某個地方在下雨的那天已經有水了，則會發生洪水，題目要求避免洪水發生，  
要求返回一個陣列 `ans`，其中 `ans[i] == -1` 表示第 `i` 天下雨，  
若 `ans[i]` 是一個正數，表示第 `i` 天沒有下雨，且在 `ans[i]` 處放水，  
相同的地方可以多次放水，只要避免 `rains[i] == 0` 的同時 `ans[i] != -1` 即可，  
如果無法避免洪水，則返回空陣列。  

## 直覺想法  

1. 使用一個 `hash map` 紀錄在目前為止每個地方最後一次下雨的天數。  
2. 如果 `rains[i] == 0` 則儲存該天數到 `hash set` 中，表示在 `i` 天之前下雨的地方可以放水。  
3. 持續走訪 `rains` 陣列，如果:  
    - `rains[i] > 0` 且該地方之前沒有下雨，則更新 `hash map`。  
    - `rains[i] > 0` 且該地方之前有下雨，則需要在 `hash set` 中找出一個天數 `j`，使得 `j > last_rain_day`，  
      如果找不到則表示無法避免洪水，回傳空陣列。  
      否則將 `ans[j]` 設為 `rains[i]`，並從 `hash set` 中移除 `j`，更新 `hash map`。  
4. 最後將所有 `ans[i]` 中仍為 `0` 的位置設為 `1`（表示隨便放水的地方），並回傳 `ans`。  

由於 `rains` 的長度最多為 `10^5`，因此必須是 $O(nlogn)$ 以下的解法，  
其中走訪並更新 `hash map` 是 $O(n)$，查找時必須小於 $O(n)$，因此使用二分搜，複雜度為 $O(logn)$，  
使用 `set` 內建的 `upper_bound` 方法來找出大於某個值的最小值即可。  

## 題解  

```cpp=
class Solution {
public:
    vector<int> avoidFlood(vector<int>& rains) {
        unordered_map<int, int> mp;
        unordered_map<int, int> pos;
        int n = rains.size();
        vector<int> res(n, -1);
        set<int> day;
        for(int i = 0; i < n; ++i) {
            int target = rains[i];
            mp[target] += 1;
            if(target == 0) {
                day.insert(i);
            } else if(mp[target] > 1) {
                if(mp[0] == 0)  return {};
                auto iter = day.upper_bound(pos[target]);
                if(iter == day.end())  return {};
                mp[0] -= 1;
                mp[target] -= 1;
                res[*iter] = target;
                day.erase(iter);
            }
            pos[target] = i;
        }
        for(int i : day) {
            res[i] = 1;
        }
        return res;
    }
};
```

Time Complexity : $O(nlogn)$  
Space Complexity : $O(n)$  

## 心得  

原本還在糾結到底怎麼在 `set` 上手刻二分搜，後來妥協使用 `set` 內建的 `upper_bound`，  
這東西這麼好用早該學起來了==  
