---
tags:
  - LeetCode
---

# [3623. Count Number of Trapezoids I](https://leetcode.com/problems/count-number-of-trapezoids-i/description/)  

+ 日期 : 2025/12/02  

## 問題描述  

給定一個二維陣列 `points` 表示平面坐標上的點，一個合法的矩形定義為有兩條平行邊與 `x` 軸平行，  
問有多少個合法的矩形可以由這些點組成。  

## 直覺想法  

1. 以 `y` 軸座標將點分組，每個 `y` 軸座標上，任取兩點即可組成一條平行於 `x` 軸的邊。  
2. 只要取到兩條平行邊，便能組成一個合法的矩形，並且組合為 `C(y_1, 2) * C(y_2, 2)`  
3. 以暴力法來看，會需要 $O(n^2)$ 時間，對於每個 `y` 軸座標的點，去找其他 `y` 軸座標的點來組合。  
4. 由於 `y` 軸範圍過大，導致 $O(n^2)$ 會 `TLE`，因此需要以 $O(n)$ 的方式來解決。  
5. 觀察 `3` 可知，計算過程會固定其中一軸，並計算他軸與此軸的組合數量並加總  
6. 因此可以反過來想，紀錄此軸與之前所有軸的數量，並以此來計算組合數量。  

## 題解  

```cpp=
class Solution {
public:
    int countTrapezoids(vector<vector<int>>& points) {
        unordered_map<int, int> mp;
        for(vector<int> &pt : points) {
            mp[pt[1]] += 1;
        }

        int MOD = 1e9 + 7;
        int res = 0;
        for(auto i = mp.begin(); i != mp.end(); ++i) {
            for(auto j = std::next(i); j != mp.end(); ++j) {
                int iv = i->second;
                int jv = j->second;
                res += ((iv * (iv-1) % MOD) / 2) * ((jv * (jv-1) % MOD) / 2) % MOD;
            }
        }
        return res;
    }
};
```

Time Complexity : $O(nlogn)$  
Space Complexity : $O(n)$  

```cpp=
class Solution {
public:
    int countTrapezoids(vector<vector<int>>& points) {
        unordered_map<int, int> mp;
        for(vector<int> &pt : points) {
            mp[pt[1]] += 1;
        }

        int MOD = 1e9 + 7;
        long long res = 0;
        long long pre = 0;
        for(auto i = mp.begin(); i != mp.end(); ++i) {
            long long val = i->second;
            long long cur = ((val * (val-1)) / 2) % MOD;
            res += pre * cur;
            pre += cur;
        }
        return res % MOD;
    }
};
```

Time Complexity : $O(n)$  
Space Complexity : $O(n)$  

## 心得  

又是數學題，我好廢  
