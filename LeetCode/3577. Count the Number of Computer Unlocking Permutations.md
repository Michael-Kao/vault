---
tags:
  - LeetCode
---

# [3577. Count the Number of Computer Unlocking Permutations](https://leetcode.com/problems/count-the-number-of-computer-unlocking-permutations/description/)  

+ 日期 : 2025/12/10  

## 問題描述  

給定一個數字陣列 `complexity`，每次將 `complexity[0]` 作為初始，  
若其中有 `complexity[i] <= complexity[0]`，則不能形成 `permutation`，回傳 `0`，  
否則回傳 `(n-1)!`，其中 `n` 為陣列長度。  

## 直覺想法  

1. 判斷陣列中是否有 `complexity[i] <= complexity[0]`，  
   - 有的話回傳 `0`。  
2. 否則回傳 `(n-1)!`。  

## 題解  

```cpp=
class Solution {
public:
    int countPermutations(vector<int>& complexity) {
        int MOD = 1e9 + 7;
        int n = complexity.size();
        int cnt = n-1;
        for(int i = 1; i < n; ++i) {
            if(complexity[i] <= complexity[0])
                return 0;
        }
        int res = 1;
        while(cnt > 0) {
            res = (1ll * res * cnt) % MOD;
            cnt -= 1;
        }
        return res;
    }
};
```

Time Complexity : $O(n)$  
Space Complexity : $O(1)$  

## 心得  

奇怪的題目  
