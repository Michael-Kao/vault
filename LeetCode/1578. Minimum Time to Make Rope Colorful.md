---
tags:
  - LeetCode
---

# [1578. Minimum Time to Make Rope Colorful](https://leetcode.com/problems/minimum-time-to-make-rope-colorful/description/)  

+ 日期 : 2025/11/03  

## 問題描述  

給定一個字串 `colors` 和一個整數陣列 `neededTime`，兩者長度相同，  
假設移除 `colors[i]` 的所需時間為 `neededTime[i]`，那麼麼要使得 `colors` 中沒有兩個相鄰的字元相同，  
最少需要花費多少時間。   

## 直覺想法  

1. 判斷當前字元是否與前一個字元相同，若相同則需要移除其中一個字元。  
2. 為了最小化花費時間，應該移除花費時間較少的字元。  
3. 回傳總和  

除此之外有更乾淨的解法  

1. 持續追蹤目前字元的最大花費時間  
2. 如果與前一個字元相同，則將目前字元較小的花費時間加入總和，並更新最大花費時間  
3. 如果不相同，則重製目前字元的最大花費時間為當前字元的花費時間  

## 題解  

```cpp=
class Solution {
public:
    int minCost(string colors, vector<int>& neededTime) {
        int res = 0;
        int pre = 0;
        int n = colors.size();
        for(int i = 1; i < n; ++i) {
            if(colors[i] == colors[pre]) {
                if(neededTime[i] < neededTime[pre]) {
                    res += neededTime[i];
                } else {
                    res += neededTime[pre];
                    pre = i;
                }
            } else {
                pre = i;
            }
        }
        return res;
    }
};
```

Time Complexity : $O(n)$  
Space Complexity : $O(1)$  

```cpp=
    int minCost(string s, vector<int>& cost) {
        int res = 0, max_cost = 0, n = s.size();
        for (int i = 0; i < n; ++i) {
            if (i > 0 && s[i] != s[i - 1])
                max_cost = 0;
            res += min(max_cost, cost[i]);
            max_cost = max(max_cost, cost[i]);
        }
        return res;
    }
```

Time Complexity : $O(n)$  
Space Complexity : $O(1)$  

## 心得  

好累  
