---
tags:
  - LeetCode
---

# [3446. Sort Matrix by Diagonals](https://leetcode.com/problems/sort-matrix-by-diagonals/description/)  

+ 日期 : 2025/08/28  

## 問題描述  

給定一個 `n x n` 的矩陣 `grid`，做以下操作：  

1. 矩陣走訪以對角線為單位，從左上到右下。  
2. 對角線以下(包含對角線)的元素進行大到小排序。  
3. 對角線以上的元素進行小到大排序。  

## 直覺想法  

基本上照著題目描述，分兩次做，  

1. 走訪 `row0 ~ row_n-1` 的對角線，並大到小排序後放回去。  
2. 走訪 `col1 ~ col_n-1` 的對角線，並小到大排序後放回去。  

另外也有人用 `min/max heap` 來操作，  
首先走訪整個矩陣，為了判斷屬於哪一條對角線，以及是上半部還是下半部，  
可以用 `row - col` 來區分，`row - col < 0` 為上半部，`row - col >= 0` 為下半部，  
且同一條對角線的 `row - col` 值是相同的，因此可以用 `row - col` 當作 key，  
value 則是該對角線的元素，由於 `min/max heap` 本身就會排序，因此在放回去的時候直接取出即可。  

## 題解  

```cpp=
class Solution {
public:
    vector<vector<int>> sortMatrix(vector<vector<int>>& grid) {
        int n = grid.size();
        vector<vector<int>> res(n, vector<int>(n));
        for(int i = 0; i < n; ++i) {
            vector<int> tmp;
            int x = i;
            int y = 0;
            while(x < n && y < n) {
                tmp.push_back(grid[x][y]);
                x += 1;
                y += 1;
            }
            sort(tmp.begin(), tmp.end(), greater<int>());
            x = i;
            y = 0;
            int idx = 0;
            while(x < n && y < n) {
                res[x][y] = tmp[idx];
                x += 1;
                y += 1;
                idx += 1;
            }
        }
        for(int i = 1; i < n; ++i) {
            vector<int> tmp;
            int x = 0;
            int y = i;
            while(x < n && y < n) {
                tmp.push_back(grid[x][y]);
                x += 1;
                y += 1;
            }
            sort(tmp.begin(), tmp.end());
            x = 0;
            y = i;
            int idx = 0;
            while(x < n && y < n) {
                res[x][y] = tmp[idx];
                x += 1;
                y += 1;
                idx += 1;
            }
        }
        return res;
    }
};
```

Time Complexity : $O(n^2 * logn)$  
Space Complexity : $O(n^2)$  

```cpp=
class Solution {
public:
    vector<vector<int>> sortMatrix(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        unordered_map<int, priority_queue<int>> maxHeaps;
        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> minHeaps;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int key = i - j;
                if (key < 0) minHeaps[key].push(grid[i][j]);
                else maxHeaps[key].push(grid[i][j]);
            }
        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int key = i - j;
                if (key < 0) {
                    grid[i][j] = minHeaps[key].top();
                    minHeaps[key].pop();
                } else {
                    grid[i][j] = maxHeaps[key].top();
                    maxHeaps[key].pop();
                }
            }
        }
        return grid;
    }
};
```

Time Complexity : $O(n^2 * logn)$  
Space Complexity : $O(n^2)$  

## 心得  

每日提醒自己要開始規劃基礎 `DP` 跟進階演算法的學習計畫  
