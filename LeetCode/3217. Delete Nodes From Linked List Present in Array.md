---
tags:
  - LeetCode
---

# [3217. Delete Nodes From Linked List Present in Array](https://leetcode.com/problems/delete-nodes-from-linked-list-present-in-array/description/)  

+ 日期 : 2025/11/01  

## 問題描述  

給一個數字陣列 `nums` 和一個 `Linked List`，走訪 `Linked List`，  
刪除 `Linked List` 中出現在 `nums` 陣列中的節點，並回傳刪除後的 `Linked List`。  

## 直覺想法  

1. 先用 `set` 或 `map` 把 `nums` 查找的時間降到 $O(1)$  
2. 建立一個 `dummy`，讓 `dummy->next = head`  
3. 從 `dummy` 開始走訪，如果 `curr->next` 還存在，判斷是否在 `set` 中，  
   - 在的話就刪除 `curr->next` 節點，並繼續判斷 `curr->next`  
   - 不在的話就把 `curr` 往前移動一格  
4. 最後回傳 `dummy->next` 即可  

## 題解  

```cpp=
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* modifiedList(vector<int>& nums, ListNode* head) {
        unordered_set<int> m_set;
        for(int num : nums) {
            m_set.insert(num);
        }
        ListNode *dummy = new ListNode(0, head);
        ListNode *cur = dummy;
        while(cur->next) {
            if(m_set.count(cur->next->val)) {
                cur->next = cur->next->next;
            } else {
                cur = cur->next;
            }
        }
        return dummy->next;
    }
};
```

Time Complexity : $O(n + m)$  
Space Complexity : $O(m)$  

## 心得  

我本來還想說可能會寫一陣子，畢竟 `Linked List` 不知道多久沒碰了，  
還好看到我以前寫過的答案，發現跟我直覺想法一模一樣，應該可以代表我算熟悉了吧  
