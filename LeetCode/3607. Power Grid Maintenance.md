---
tags:
  - LeetCode
---

# [3607. Power Grid Maintenance](https://leetcode.com/problems/power-grid-maintenance/description/)  

+ 日期 : 2025/11/06  

## 問題描述  

給定一個整數 `c` 表示有 `c` 個節點，一個二維陣列 `connections` 表示節點之間的連接關係，該連接為雙向，  
給一組二維陣列 `queries`，當 `queries[i] = {1, a}`，若節點 `a` 未被關閉，則回傳節點 `a`，  
若節點 `a` 被關閉，則回傳與節點 `a` 連接的且編號最小的未被關閉節點，若所有連接的節點皆被關閉，則回傳 `-1`，  
當 `queries[i] = {2, a}`，表示關閉節點 `a`。  

## 直覺想法  

1. 使用 `Union & Find` 將各節點相連  
2. 建立 `Union` 同時使用 `ordered set` 紀錄目前相連點有哪些  
3. 根據 `queries` 決定回傳還是移除 `set` 中的節點  

## 題解  

```cpp=
class UnionFind {
public:
    int n;
    vector<bool> online;
    vector<int> parent;
    vector<set<int>> comp;
    UnionFind(int _n): n(_n+1), online(vector<bool>(_n+1, true)), comp(vector<set<int>>(_n+1))
    {
        parent = vector<int>(n+1);
        for(int i = 1; i < n; ++i) {
            parent[i] = i;
            comp[i].insert(i);
        }
    }

    void Union(int x, int y) {
        int px = FindP(x);
        int py = FindP(y);

        if(px == py)    return;

        if(comp[px].size() >= comp[py].size()) {
            parent[py] = px;
            for(int c : comp[py]) {
                comp[px].insert(c);
            }
            comp[py].clear();
        } else {
            parent[px] = py;
            for(int c : comp[px]) {
                comp[py].insert(c);
            }
            comp[px].clear();
        }
    }

    int FindP(int x) {
        if(parent[x] == x)
            return x;
        return parent[x] = FindP(parent[x]);
    }
    
    int Find(int x) {
        if(online[x])   return x;
        int px = FindP(x);
        if(comp[px].empty())    return -1;
        return *comp[px].begin();
    }

    void Remove(int x) {
        online[x] = false;
        int px = FindP(x);
        comp[px].erase(x);
    }
};
class Solution {
public:
    vector<int> processQueries(int c, vector<vector<int>>& connections, vector<vector<int>>& queries) {
        UnionFind uf(c);
        for(vector<int> conn : connections) {
            uf.Union(conn[0], conn[1]);
        }
        vector<int> res;
        for(int i = 0; i < queries.size(); ++i) {
            if(queries[i][0] == 1) {
                res.push_back(uf.Find(queries[i][1]));
            } else {
                uf.Remove(queries[i][1]);
            }
        }
        return res;
    }
};
```

Time Complexity : $O(nlogn)$  
Space Complexity : $O(n)$  

## 心得  

能解決問題的答案都是好答案  
