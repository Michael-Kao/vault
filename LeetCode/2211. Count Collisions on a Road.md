---
tags:
  - LeetCode
---

# [2211. Count Collisions on a Road](https://leetcode.com/problems/count-collisions-on-a-road/description/)  

+ 日期 : 2025/12/04  

## 問題描述  

給一個字串 `directions`，表示一條道路上車輛的行駛方向。字串中的每個字元可以是以下三種之一：  

- `L` 表示車輛向左行駛  
- `R` 表示車輛向右行駛  
- `S` 表示車輛停在原地  

當兩輛車相撞時，它們會停下來並變成 `S`。  
如果一輛車向左行駛並與一輛向右行駛的車相撞，或者一輛向右行駛的車與一輛停在原地的車相撞，或者一輛向左行駛的車與一輛停在原地的車相撞，都會發生碰撞。  
`L` 和 `R` 碰撞加兩分，`L` 和 `S` 碰撞加一分，`R` 和 `S` 碰撞加一分，計算並返回所有車輛發生碰撞的總次數。  

## 直覺想法  

用 `stack` 模擬整個過程  

1. `R` 作為 `1`  
2. `S` 作為 `0`  
3. `L` 作為 `-1`  
4. 如果目前是 `R`，則當前潛在碰撞至少為 `1`，若潛在碰撞大於 `1`，表示左側有多個 `R`，可以將其加總  
5. 如果目前是 `S`，則結果加上潛在碰撞數，並將潛在碰撞數歸零  
6. 如果目前是 `L`，且潛在碰撞大於 `0`，表示除了潛在碰撞次數外，還會有向左對撞的 `L` 也會撞上，因此結果加上 `1`，並將潛在碰撞數歸零  

## 題解  

```cpp=
class Solution {
public:
    int countCollisions(string directions) {
        int res = 0;
        int flag = -1;
        for (auto c : directions) {
            if (c == 'L') {
                if (flag >= 0) {
                    res += flag + 1;
                    flag = 0;
                }
            } else if (c == 'S') {
                if (flag > 0) {
                    res += flag;
                }
                flag = 0;
            } else {
                if (flag >= 0) {
                    flag++;
                } else {
                    flag = 1;
                }
            }
        }
        return res;
    }
};
```

Time Complexity : $O(n)$  
Space Complexity : $O(1)$  

```cpp=
class Solution {
public:
    int countCollisions(string directions) {
        stack<char> stk;
        int res = 0;
        for(char c : directions) {
            if(c == 'R') {
                stk.push(c);
            } else if(c == 'L') {
                char cur = c;
                while(!stk.empty()) {
                    char top = stk.top();
                    stk.pop();
                    res += (cur == 'L' && top == 'R') ? 2 : 1;
                    cur = 'S';
                    if(!stk.empty() && stk.top() == 'S')
                        break;
                }
                if(cur != 'L')
                    stk.push('S');
            } else {
                while(!stk.empty() && stk.top() != 'S' && stk.top() != 'L') {
                    res += 1;
                    stk.pop();
                }
                stk.push('S');
            }
        }
        return res;
    }
};
```

Time Complexity : $O(n)$  
Space Complexity : $O(1)$  

## 心得  

我可悲到這題 `Error` 外還用了額外的 `stack` 解==  
下班乖乖下班，別羞辱自己了  
