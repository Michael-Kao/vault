---
tags:
  - LeetCode
---

# [3479. Fruits Into Baskets III](https://leetcode.com/problems/fruits-into-baskets-iii/description/)  

+ 日期 : 2025/08/06  

## 問題描述  

同 [[3477-fruits-into-baskets-iihttpsleetcodecomproblemsfruits-into-baskets-iidescription]]，但 $O(n^2)$ 過不了。  

## 直覺想法  

使用線段樹 + 二分搜  

## 題解  

```cpp=
class Solution {
public:
    int numOfUnplacedFruits(vector<int>& fruits, vector<int>& baskets) {
        int n = fruits.size();
        vector<int> segTree(4*n, 0);
        build(baskets, segTree, 1, 0, n-1);
        int res = 0;
        for(int i = 0; i < n; ++i) {
            int l = 0;
            int r = n-1;
            int pos = -1;
            while(l <= r) {
                int mid = (l + r) / 2;
                if(query(segTree, 1, 0, n-1, 0, mid) >= fruits[i]) {
                    pos = mid;
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }
            if(pos != -1 && baskets[pos] >= fruits[i]) {
                update(segTree, 1, 0, n-1, pos, 0);
            } else {
                res += 1;
            }
        }
        return res;
    }

    void build(vector<int> &arr, vector<int> &segTree, int idx, int l, int r) {
        if(l == r) {
            segTree[idx] = arr[l];
            return;
        }

        int mid = (l + r) / 2;
        build(arr, segTree, 2 * idx, l, mid);
        build(arr, segTree, 2 * idx + 1, mid + 1, r);
        segTree[idx] = max(segTree[2*idx], segTree[2*idx+1]);
    }

    int query(vector<int> &segTree, int idx, int l, int r, int ql, int qr) {
        if(ql > r || qr < l)
            return 0;
        if(ql <= l && r <= qr)
            return segTree[idx];
        
        int mid = (l + r) / 2;
        return max(
            query(segTree, 2*idx, l, mid, ql, qr),
            query(segTree, 2*idx+1, mid+1, r, ql, qr)
        );
    }

    void update(vector<int> &segTree, int idx, int l, int r, int pos, int value) {
        if(l == r) {
            segTree[idx] = value;
            return;
        }
        int mid = (l + r) / 2;
        if(pos > mid) {
            update(segTree, 2*idx+1, mid+1, r, pos, value);
        } else {
            update(segTree, 2*idx, l, mid, pos, value);
        }
        segTree[idx] = max(segTree[2*idx], segTree[2*idx+1]);
    }
};
```

Time Complexity : $O(nlogn)$  
Space Complexity : $O(4n)$  

## 心得  

今天學了線段樹，但實作還是超卡==  
這種東西真的有學的必要嗎  
