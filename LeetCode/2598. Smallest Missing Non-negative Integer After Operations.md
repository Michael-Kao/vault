---
tags:
  - LeetCode
---

# [2598. Smallest Missing Non-negative Integer After Operations](https://leetcode.com/problems/smallest-missing-non-negative-integer-after-operations/description/)  

+ 日期 : 2025/10/16  

## 問題描述  

給定一個數字陣列 `nums` 和整數 `value`，可以對 `nums` 上的任意元素進行任意次數的加或減 `value` 操作。  
請問將 `nums` 經過這些操作後，最小的缺失非負整數是什麼？  

假設 `nums = [1,-10,7,13,6,8]` 且 `value = 5`，經過操作後，`nums` 可以變成 `[6,0,2,3,1,4]`，  
因此最小的缺失非負整數是 `5`。  

## 直覺想法  

1. 將 `nums` 中的每個數字對 `value` 取餘數，並計算其數量  
2. 從 `0` 開始檢查每個非負整數，看看它是否可以由 `nums` 中的數字經過加減 `value` 操作得到  

## 題解  

```cpp=
class Solution {
public:
    int findSmallestInteger(vector<int>& nums, int value) {
        vector<int> mp(value);
        for (auto& x : nums) {
            int v = (x % value + value) % value;
            mp[v]++;
        }
        int mex = 0;
        while (mp[mex % value] > 0) {
            mp[mex % value]--;
            mex++;
        }
        return mex;
    }
};
```

Time Complexity : $O(n)$  
Space Complexity : $O(value)$  

## 心得  

我只想到可以使用餘數來找出潛在的非負整數，但是如何找卻想不到，  
這就是 Greedy 出現的地方，從所有可能中去找，只要目前這個餘數還有數量，  
表示可以組成這個數字，然後將數量減一，繼續找下一個數字，直到找不到為止。  
