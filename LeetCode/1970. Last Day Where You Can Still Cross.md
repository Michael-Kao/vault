---
tags:
  - LeetCode
---

# [1970. Last Day Where You Can Still Cross](https://leetcode.com/problems/last-day-where-you-can-still-cross/description/)  

+ 日期 : 2025/12/31  

## 問題描述  

給定一個 `row x col` 的二維陣列，`1` 表示有水不能通過，`0` 表示陸地可以通過，此外還有一個二維陣列 `cells`，  
為 `1-based` 組成的座標，表示第 `i` 天會把 `cells[i]` 的位置變成水，請找出最後一天還能從最上方通過到最下方的天數。  

## 直覺想法  

1. 使用二分搜找可能的最後一天  
2. 選定天數後，建立 `grid` 網格  
3. 將 `grid[0][i]` 中不為 `1` 的位置存放在 `queue` 中  
4. 使用 `BFS` 往下走，若能走到 `grid[row-1]`，表示可以通過，回傳 `True`，否則回傳 `False`  
5. 若可以通過，則將 `left` 往右移動，否則將 `right` 往左移動  

## 題解  

```cpp=
class Solution {
public:
    int latestDayToCross(int row, int col, vector<vector<int>>& cells) {
        int l = 0;
        int r = cells.size()-1;
        vector<vector<int>> grid(row, vector<int>(col, 0));
        vector<vector<bool>> seen(row, vector<bool>(col, false));
        queue<pair<int, int>> q;

        int res = 0;
        while(l <= r) {
            int mid = (r - l) / 2 + l;

            for(int i = 0; i <= mid; ++i) {
                int x = cells[i][0] - 1;
                int y = cells[i][1] - 1;

                grid[x][y] = 1;
            }
            bool pass = false;

            for(int i = 0; i < col; ++i) {
                if(!grid[0][i]) {
                    q.push({0, i});
                    seen[0][i] = true;
                }
            }
            if(bfs(grid, q, seen)) {
                res = mid + 1;
                l = mid + 1;
            } else {
                r = mid - 1;
            }

            grid = vector<vector<int>>(row, vector<int>(col, 0));
            q = queue<pair<int, int>>();
            seen = vector<vector<bool>>(row, vector<bool>(col, false));
        }
        return res;
    }

    vector<vector<int>> dir = {
        {0, 1},
        {0, -1},
        {1, 0},
        {-1, 0}
    };

    bool bfs(vector<vector<int>> &grid, queue<pair<int, int>> &q, vector<vector<bool>> &seen) {
        int m = grid.size();
        int n = grid[0].size();
        while(!q.empty()) {
            auto [x, y] = q.front();
            if(x == m-1)    return true;
            q.pop();

            for(int i = 0; i < 4; ++i) {
                int nx = x + dir[i][0];
                int ny = y + dir[i][1];

                if(nx < 0 || ny < 0 || nx >= m || ny >= n || seen[nx][ny])
                    continue;
                if(grid[nx][ny])
                    continue;
                
                seen[nx][ny] = true;
                q.push({nx, ny});
            }
        }
        return false;
    }
};
```

Time Complexity : $O(row*col*log{row*col})$  
Space Complexity : $O(row*col)$  

## 心得  

爽啦終於寫完一整年了  
