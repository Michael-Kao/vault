---
tags:
  - LeetCode
---

# [2787. Ways to Express an Integer as Sum of Powers](https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/description/)  

+ 日期 : 2025/08/12  

## 問題描述  

給定一個整數 `n` 和一個整數 `x`，存在 `num_i^x` 總和等於 `n`，其中 `num_i` 為正整數，  
求滿足以上條件的組合數量。  

## 直覺想法  

基本上就是從 `[1, n]`，每個數字可以選跟不選，只要當前加總為 `n`，表示有一組符合，  
典型 `DFS` 問題，然後搭配上 `Memoization` 優化。  

## 題解  

```cpp=
class Solution {
public:
    int MOD = 1e9 + 7;
    int numberOfWays(int n, int x) {
        vector<vector<int>> memo(n+1, vector<int>(n+1, -1));
        return helper(1, x, n, memo);
    }

    int helper(int num, int x, int target, vector<vector<int>> &memo) {
        if(target == 0) return 1;
        if(target < 0 || num > target)  return 0;
        if(memo[num][target] != -1)
            return memo[num][target];

        int cur = 1;
        for(int i = 0; i < x; ++i) {
            cur = (1ll * cur * num) % MOD;
        }
        memo[num][target] = (helper(num+1, x, target, memo) + 
            helper(num+1, x, target - cur, memo)) % MOD;

        return memo[num][target];
    }
};
```

Time Complexity : $O(n\sqrt[x]{n})$  
Space Complexity : $O(n^2)$  

當然其實這題應該直接用 `DP` 而不是 `memoization` 會更好，但我能力不足QQ  

```cpp=
class Solution {
public:
    int numberOfWays(int n, int x) {
        long long mod = 1e9 + 7;
        vector<vector<long long>> dp(n + 1, vector<long long>(n + 1));
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            long long val = pow(i, x);
            for (int j = 0; j <= n; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= val) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - val]) % mod;
                }
            }
        }
        return dp[n][n];
    }
};
```

Time Complexity : $O(n\sqrt[x]{n})$  
Space Complexity : $O(n^2)$  

```cpp=
class Solution {
public:
    int numberOfWays(int n, int x) {
        long long mod = 1e9 + 7;
        vector<long long> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            long long val = pow(i, x);
            if (val > n) {
                break;
            }
            for (int j = n; j >= val; j--) {
                dp[j] = (dp[j] + dp[j - val]) % mod;
            }
        }
        return dp[n];
    }
};
```

Time Complexity : $O(n\sqrt[x]{n})$  
Space Complexity : $O(n)$  

## 心得  

能用 `memoization` 解的題目都算簡單的，我程度就到這了  
要往上必須安排時間開刷  
