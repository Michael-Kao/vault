---
tags:
  - LeetCode
---

# [417. Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/)  

+ 日期 : 2025/10/05  

## 問題描述  

給定一個 `m x n` 的矩陣 `heights` ，表示一個地形圖，其中 `heights[r][c]` 是該位置的高度，  
假設太平洋在左邊和上邊，大西洋在右邊和下邊，並且水只能從高處流向低處或相同高度的地方，  
問在 `heights` 中哪些位置的水可以同時流向太平洋和大西洋？  

## 直覺想法  

最直觀可能想說看過每個位置，判斷該位置能不能到達兩個海洋，  
透過 `BFS` 或 `DFS` 可以走訪所有能到達的位置，但是查看每個位置的時間複雜度是 $O((mn)^2)$，  
為了減少複雜度，我們必須反向思考，先找出邊界上能到達太平洋或大西洋的位置，  
根據該位置逆流回去，如果該位置原先從太平洋來，那麼逆流回去的位置也能到達太平洋，  
同理大西洋也是一樣，最後找出兩個海洋都能到達的位置即可。  

1. 建立兩個 `m x n` 的布林矩陣 `pacific` 和 `atlantic`，分別表示該位置能否到達太平洋和大西洋。  
2. 從邊界位置開始，對每個位置進行 `DFS` 或 `BFS`，將能到達的位置標記為 `True`。  
3. 最後遍歷整個矩陣，找出同時在 `pacific` 和 `atlantic` 中為 `True` 的位置。  

## 題解  

```cpp=
class Solution {
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        int m = heights.size();
        int n = heights[0].size();
        vector<vector<bool>> pac(m, vector<bool>(n, false));
        vector<vector<bool>> atl(m, vector<bool>(n, false));
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                if(i == 0 || j == 0)
                    pac[i][j] = true;
                if(i == m-1 || j == n-1)
                    atl[i][j] = true;
            }
        }
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                if(pac[i][j])
                    dfs(heights, i, j, pac);
                if(atl[i][j])
                    dfs(heights, i, j, atl);
            }
        }
        vector<vector<int>> res;
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                if(pac[i][j] && atl[i][j])
                    res.push_back({i, j});
            }
        }
        return res;
    }

    void dfs(vector<vector<int>> &heights, int r, int c, vector<vector<bool>> &mark) {
        // declare 4 dir in a vector is slow af
        vector<vector<int>> dir = {
            {0, 1},
            {0, -1},
            {1, 0},
            {-1, 0}
        };

        for(int i = 0; i < 4; ++i) {
            int nr = r + dir[i][0];
            int nc = c + dir[i][1];

            if(nr < 0 || nr == heights.size() || nc < 0 || nc == heights[0].size())
                continue;
            if(mark[nr][nc])
                continue;
            if(heights[nr][nc] < heights[r][c])
                continue;
            mark[nr][nc] = true;
            dfs(heights, nr, nc, mark);
        }
    }
};
```

Time Complexity : $O(mn)$  
Space Complexity : $O(mn)$  

## 心得  

沒去看討論區我也一直卡死，想不懂要怎麼同時處理兩個海洋，  
以後要記得如果解不出來就是拆不夠細==  
