---
tags:
  - LeetCode
---

# [778. Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/description/)  

+ 日期 : 2025/10/06  

## 問題描述  

給一個 `n x n` 的數字矩陣 `grid` ，每個格子 `grid[i][j]` 代表在時間 `t = grid[i][j]` 時該格子會被水淹沒，  
問在時間 `t` 時，從左上角 `(0, 0)` 到右下角 `(n-1, n-1)` 的最小時間是多少？  

## 直覺想法  

這題是在問有權重的情況下(時間)，從起點到終點的最短路徑，  
而這種類型可以使用 `Dijkstra` 來解決。  

1. 將起點 `{start_time, {0, 0}}` 放入 `min Heap` 中，並將 `visited` 設為 `True`。  
   使用 `min Heap` 原因在於我們想要每次都能取出目前時間最小的點來進行擴展，因此時間小的點會優先被處理。  
2. 每次從 `min Heap` 取出時間最小的點，並更新由該點能抵達的鄰近點的時間，  
   若鄰近點未被拜訪過，則將其加入 `min Heap` 中，並標記為已拜訪。  
3. 由於 `min Heap` 已經確保每次走的路徑時間最小，因此只要更新該路徑上的最大時間即可，即 `max(current_time, neighbor_time)`。  
4. 當所有點都走過，`grid[n-1][n-1]` 即為所求的最小時間。  

## 題解  

```cpp=
class Solution {
public:
    int swimInWater(vector<vector<int>>& grid) {
        int n = grid.size();
        vector<vector<int>> dir = {
            {0, 1},
            {0, -1},
            {1, 0},
            {-1, 0}
        };
        vector<vector<bool>> seen(n, vector<bool>(n, false));
        priority_queue<pair<int, pair<int, int>>> minHeap;
        minHeap.push({-grid[0][0], {0, 0}});
        seen[0][0] = true;
        while(!minHeap.empty()) {
            auto top = minHeap.top();
            int t = -top.first;
            auto [r, c] = top.second;
            minHeap.pop();
            for(int i = 0; i < 4; ++i) {
                int nr = r + dir[i][0];
                int nc = c + dir[i][1];

                if(nr < 0 || nc < 0 || nr == n || nc == n)
                    continue;
                if(seen[nr][nc])
                    continue;
                seen[nr][nc] = true;
                int nt = max(grid[nr][nc], t);
                grid[nr][nc] = nt;
                minHeap.push({-nt, {nr, nc}});
            }
        }
        return grid[n-1][n-1];
    }
};
```

Time Complexity : $O(mnlogmn)$  
Space Complexity : $O(mn)$  

## 心得  

基礎資料結構 + 演算法的題目，雖然沒有 `one try pass`，但整體寫完在 30 分鐘內，  
應該還可以？  
