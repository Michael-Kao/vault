---
tags:
  - LeetCode
---

# [2353. Design a Food Rating System](https://leetcode.com/problems/design-a-food-rating-system/description/)  

+ 日期 : 2025/09/17  

## 問題描述  

給定兩組字串陣列 `foods` 和 `cuisines`，以及一組整數陣列 `ratings`，  
實作一個資料結構，該資料結構輸入為以上三個陣列，並支援以下兩個方法：  

1. 選擇一個料理 `food`，並更新其評分為 `newRating`。  
2. 回傳指定料理類別 `cuisine` 中評分最高的料理名稱。如果有多個料理評分相同，則回傳字典序較小的料理名稱。  

## 直覺想法  

這題要能快速找到 `food` 對應的 `cuisine` 以及 `rating` 的話必須使用 `Hash Map / Hash Set`，  
難度高的地方在於取出評分高以及修改上，當然我們可以用 $O(n)$ 的方式去更新資料，  
但這樣效率極差，為了達到快速取出評分高的料理，可以想到有排序的資料結構，  
即 `Map / Set / Max Heap` 等等，由於每到料理是可以進行更新的，其中 `Max Heap` 只能知道最高分的料理，  
無法知道其他料理的分數，因此在更新上反而更困難，所以選擇只剩下 `Map / Set`，最後是由於每到料理的評分唯一，  
因此可以使用 `{rating, food}` 作為儲存依據，使用 `Set` 即可  

1. 使用 `3` 個 `Hash Map` 來儲存，分別是 `food -> cuisine`, `cuisine -> Set{(rating, food)}`, `food -> rating`  
2. 更新時先刪除原本的 `(rating, food)`，再插入新的 `(newRating, food)`  
3. 取出最高分的料理時，直接回傳 `Set` 中的第一個元素即可  

## 題解  

```cpp=
class comp {
public:
    bool operator()(const pair<int, string> &a, const pair<int, string> &b) const {
        if(a.first == b.first)
            return a.second < b.second;
        return a.first > b.first;
    }
};

class FoodRatings {
public:
    unordered_map<string, string> toCuisine;
    unordered_map<string, int> toRate;
    unordered_map<string, set<pair<int, string>, comp>> toMax;
    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {
        int n = foods.size();
        for(int i = 0; i < n; ++i) {
            string food = foods[i];
            string cuisine = cuisines[i];
            int rate = ratings[i];
            toCuisine[food] = cuisine;
            toRate[food] = rate;
            toMax[cuisine].insert({rate, food});
        }
    }
    
    void changeRating(string food, int newRating) {
        string cuisine = toCuisine[food];
        int rate = toRate[food];
        toMax[cuisine].erase({rate, food});
        toRate[food] = newRating;
        toMax[cuisine].insert({newRating, food});
    }
    
    string highestRated(string cuisine) {
        return toMax[cuisine].begin()->second;
    }
};

/**
 * Your FoodRatings object will be instantiated and called as such:
 * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);
 * obj->changeRating(food,newRating);
 * string param_2 = obj->highestRated(cuisine);
 */
```

Time Complexity : $O(nlogn)$  
Space Complexity : $O(n)$  

## 心得  

今天學到由於 `Set` 的 `key` 是不能更動，因此在實作自製的 `comparator` 時一定要加入 `const`，  
除此之外本題好像就這樣而已，有學到東西，好耶  
