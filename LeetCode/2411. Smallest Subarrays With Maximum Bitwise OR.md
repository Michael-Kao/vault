---
tags:
  - LeetCode
---

# [2411. Smallest Subarrays With Maximum Bitwise OR](https://leetcode.com/problems/smallest-subarrays-with-maximum-bitwise-or/description/)  

+ 日期 : 2025/07/29  

## 問題描述  

給定一個數字陣列 `nums`，以每個 `index` 作為起點，從 `nums[i] ~ nums[n-1]` 中，  
所有 `OR` 出來最大的值為 `target`，請回傳一個長度為 `n` 的陣列 `ans`，  
其中 `ans[i]` 為從 `nums[i]` 開始，最小的子陣列長度，使得該子陣列的 `OR` 值為 `target`。  

## 直覺想法  

找到最小子陣列的 `OR` 值為 `target`，其中 `target` 為 `nums[i] | nums[i+1] | ... | nums[n-1]`，  
如果從 `i == 0` 開始，我們並不知道後方的值，因此本題該從 `i = n - 1` 開始，  
然後開始建立一個 `bitwise OR` 對於每個 `bit` 由哪個 `index` 貢獻的陣列，  
如果當前 `bit` 由 `nums[i]` 貢獻，那麼最小子陣列長度就是 `1`，  
如果當前 `bit` 無法透過 `nums[i]` 取得，那麼陣列右側必須是所有看過的 `bit` 的最大 `index`，  
表示至少要到 `index j` 才能符合目前的 `target`。  

## 題解  

```cpp=
class Solution {
public:
    vector<int> smallestSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> pos(31, -1);
        vector<int> ans(n);
        for (int i = n - 1; i >= 0; --i) {
            int j = i;
            for (int bit = 0; bit < 31; ++bit) {
                if (!(nums[i] & (1 << bit))) {
                    if (pos[bit] != -1) {
                        j = max(j, pos[bit]);
                    }
                } else {
                    pos[bit] = i;
                }
            }
            ans[i] = j - i + 1;
        }
        return ans;
    }
};
```

Time Complexity : $O(n*logC)$  
Space Complexity : $O(32)$  

## 心得  

這題蠻漂亮的，我直到看懂題解的 `code` 才意識到，他要的 `target` 是從 `i` 開始到 `n-1` 的 `OR` 值，  
一開始就想錯方向了，有想到用 `32 bits` 處理但完全不知道怎麼增減，下次記得看清楚題目，  
不然依照那個 `target` 的定義，怎麼想都不會從 `i = 0` 開始 ==  
