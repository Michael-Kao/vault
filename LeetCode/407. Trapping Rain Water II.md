---
tags:
  - LeetCode Leetcode
title: 407. Trapping Rain Water II
---

# [407. Trapping Rain Water II](https://leetcode.com/problems/trapping-rain-water-ii/description/?envType=daily-question&envId=2025-01-19)  

+ 日期 ：2025/01/19  

## 問題描述  

給一個 2D array ，每個值代表該格子的高度，根據高度可以組成一個 3D 的空間，由於每個格子高度可能不同，會出現某格子高度會低於四周的最大高度，問這些被圍住的格子的體積量為多少。  

## 直覺想法  

沒有想法，除了知道邊界不能儲存外不知道怎麼處理，不過反過來想，我們可以從外圍開始處理，畢竟不能儲存後只剩下高度需要判斷能不能作為合格的外牆，那應該怎麼找？  

首先要知道外牆越高當然越好，但能儲存的體積是由四周的高點中選最低的，因此我們從最小的開始找 (使用到 minHeap) ，知道當前高度後當然是去找該格子四周還沒走過的，畢竟要知道高度後還要看附近有沒有比較矮的點可以儲存 (利用 BFS) ，因為從小的開始看，所以當四周有比格子高度低的，則在演算法下一個觀察的就會是低點，再將兩者高度相減就能得到該格子能儲存的量。  

> [!Caution]
> [LeetCode Solution](https://leetcode.com/problems/trapping-rain-water-ii/solutions/1138028/python3-visualization-bfs-solution-with-explanation/?envType=daily-question&envId=2025-01-19) 這個人的題解將演算法每個步驟圖像化，上述描述不清楚建議看過這個。  

## 題解  

> [!Important]
> 這題我根本不知道怎麼想出來的，也不清楚如何證明，當然想證明錯誤最快的方法是提供反例，如果面試遇到的話，有記得算賺到，沒記得怎麼解也賺到，代表公司可能不太缺人吧。  

```cpp=
class Solution {
public:
    int trapRainWater(vector<vector<int>>& heightMap) {
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, std::greater<pair<int, pair<int, int>>>> minHeap;
        int m = heightMap.size(), n = heightMap[0].size();
        vector<vector<int>> visited(m, vector<int>(n, 0));
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                if(i == 0 || i == m - 1 || j == 0 || j == n - 1) {
                    minHeap.push({heightMap[i][j], {i, j}});
                    visited[i][j] = 1;
                }
            }
        }

        int res = 0;
        int maxH = -1;
        while(!minHeap.empty()) {
            auto top = minHeap.top();
            minHeap.pop();
            int h = top.first;
            int r = top.second.first;
            int c = top.second.second;
            
            maxH = max(maxH, h);
            res += maxH - h;

            vector<vector<int>> dir = {
                {0, 1},
                {0, -1},
                {1, 0}, 
                {-1, 0}
            };
            for(int i = 0; i < 4; ++i) {
                int nr = r + dir[i][0];
                int nc = c + dir[i][1];

                if(nr < 0 || nr == m || nc < 0 || nc == n ||
                    visited[nr][nc])
                    continue;
                
                visited[nr][nc] = 1;
                minHeap.push({heightMap[nr][nc], {nr, nc}});
            }
        }
        return res;
    }
};
```

Time Complexity : $O(m * n * log(m * n))$  
Space Complexity : $O(m * n)$  

+ $log(m*n)$ 是 minHeap 在平衡時所需的時間  

### Update  

如果把 `dir` 從 `loop` 裡面拿出來能更快一點  
然後再來是這題的想法，最困難應該是怎麼想到先把外圍當邊界，  
能想到這點的話，接下來只要把邊界當成水，讓水往內流，  
如果遇到比水低的點就能儲存水，反之遇到更高的就當作障礙物，  
因為用 `minHeap`，所以每次都是從最低的水位開始往內流，  
不會有蓋過去的問題。  

```cpp=
class Solution {
public:
    int trapRainWater(vector<vector<int>>& heightMap) {
        int m = heightMap.size();
        int n = heightMap[0].size();
        vector<vector<bool>> seen(m, vector<bool>(n, false));
        priority_queue<
            pair<int, pair<int, int>>,
            vector<pair<int, pair<int, int>>>,
            std::greater<pair<int, pair<int, int>>>
        > minHeap;
        
        vector<vector<int>> dir = {
            {0, 1},
            {0, -1},
            {1, 0},
            {-1, 0}
        };

        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                if(i == 0 || j == 0 || i == m-1 || j == n-1) {
                    minHeap.push({heightMap[i][j], {i, j}});
                    seen[i][j] = true;
                }
            }
        }

        int res = 0;
        while(!minHeap.empty()) {
            auto top = minHeap.top();
            minHeap.pop();
            int height = top.first;
            auto [row, col] = top.second;
            for(int i = 0; i < 4; ++i) {
                int nr = row + dir[i][0];
                int nc = col + dir[i][1];

                if(nr >= 0 && nr < m && nc >= 0 && nc < n && !seen[nr][nc]) {
                    res += max(0, height - heightMap[nr][nc]);
                    minHeap.push({max(height, heightMap[nr][nc]), {nr, nc}});
                    seen[nr][nc] = true;
                }
            }
        }
        return res;
    }
};
```

Time Complexity : $O(m * n * log(m * n))$  
Space Complexity : $O(m * n)$  

## 心得  

難阿，不知道一般人怎麼想出來的，這種題目是別想太多，給大佬去秀的，不會的話別放在心上。  
