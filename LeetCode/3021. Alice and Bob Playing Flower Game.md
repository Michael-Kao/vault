---
tags:
  - LeetCode
---

# [3021. Alice and Bob Playing Flower Game](https://leetcode.com/problems/alice-and-bob-playing-flower-game/description/)  

+ 日期 : 2025/08/29  

## 問題描述  

給定兩個整數 `m` 和 `n`，總共有兩個 `row`，`row_0` 可以存放 `[1, m]`，`row_1` 可以存放 `[1, n]`，  
兩個玩家在兩個 `row` 上進行遊戲，遊戲規則如下：  

1. `Alice` 必定先手  
2. 玩家在自己回合中任選一個 `row`，並取走該 `row` 上的一個數字 `x`，並換下一位玩家  
3. 當最後一個數字被取走時，遊戲結束，且取走最後一個數字的玩家獲勝  

問 `Alice` 必定獲勝的情況下，`m` 跟 `n` 的組合可能有幾種  

## 直覺想法  

首先 `row` 上的組合只能有以下可能：  

1. 奇 + 奇  
2. 奇 + 偶  
3. 偶 + 奇  
4. 偶 + 偶  

根據組合的情況進行遊戲推算，可以發現 `Alice` 先手的情況下，  
要獲勝必須兩個 `row` 總和為奇數，原因在於當兩個 `row` 總和為偶數時，  
後手者會取完，這樣 `Alice` 就無法獲勝，因此 `Alice` 的獲勝條件為情況 `2` 和 `3`。  

知道組合後，就能針對 `m` 跟 `n` 去計算該奇數和偶數的數量，  
由於可自由搭配，因此會是 `奇0 * 偶1 + 偶0 * 奇1`。  

## 題解  

```cpp=
class Solution {
public:
    long long flowerGame(int n, int m) {
        // 1 + 2x >= n, x = (n-1)/2
        int nodd = (n-1) / 2;
        if((n-1) & 1)
            nodd += 1;
        int neven = n - nodd;
        int modd = (m-1) / 2;
        if((m-1) & 1)
            modd += 1;
        int meven = m - modd;

        return 1ll * nodd * meven + 1ll * neven * modd;
    }
};
```

Time Complexity : $O(1)$  
Space Complexity : $O(1)$  

## 心得  

上班後意識到講解是個大學問，沒出社會還真不知道要怎麼講解清楚，  
雖然當初寫題解的方向就是要訓練統整資訊的能力，但沒反潰還真的不知道問題，  
希望未來的題解會寫的更好懂。  
