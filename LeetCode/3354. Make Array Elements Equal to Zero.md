---
tags:
  - LeetCode
---

# [3354. Make Array Elements Equal to Zero](https://leetcode.com/problems/make-array-elements-equal-to-zero/description/)  

+ 日期 : 2025/10/28  

## 問題描述  

給定一個整數陣列 `nums`，找到 `nums[pos] = 0` 當作起點，  
可以選擇將 `pos` 左移或右移，如果遇到 `nums[pos] != 0`，則 `nums[pos] -= 1`，並改變方向，  
問總共能完成多少個 `nums` 元素變成 `0` 的操作。  

## 直覺想法  

1. 找到 `nums[i] = 0` 作為起點  
2. 先以往左移出發，如果模擬完成後 `nums` 都為 `0`，則答案 `+1`  
3. 接著往右移出發，模擬完成後 `nums` 都為 `0`，則答案 `+1`  
4. 重複直到所有 `nums[i] = 0` 都被當作起點模擬過  

以上方法是透過模擬的方式，由於碰到 `nums[i] != 0` 時會改變方向，  
因此可知當 `nums[i] = 0` 時，若左側數字與右側數字相同，那麼最終兩邊都會歸 `0`，並且照初始方向前進，  
而當左右兩側數字差距 `= 1` 時，可以將起始方向往數字較大的一側前進，最終兩側也會歸 `0`，  
除此之外的情況都無法讓所有數字歸 `0`，因此可以使用 `prefix sum` 來加快解題。  

1. 計算在 `i` 之前的總和，`prefix[i] = total`  
2. 假設 `nums[i] = 0`，那麼 `left = prefix[i], right = total - prefix[i]`  
3. 計算兩者差距 `diff = abs(left - right)`，  
   - 若 `diff = 0`，則表示兩側數字相同，往左或右都可以完成操作，答案 `+2`  
   - 若 `diff = 1`，則表示兩側數字差距為 `1`，往總數多的方向可以完成操作，答案 `+1`  
   - 否則無法完成操作，繼續下一個起點  

## 題解  

```cpp=
class Solution {
public:
    int countValidSelections(vector<int>& nums) {
        int n = nums.size();
        int res = 0;
        for(int i = 0; i < n; ++i) {
            if(nums[i] == 0) {
                res += valid(nums, i, -1);
                res += valid(nums, i, 1);
            }
        }
        return res;
    }

    int valid(vector<int> nums, int cur, int dir) {
        int n = nums.size();

        while(cur >= 0 && cur < n) {
            if(nums[cur] > 0) {
                nums[cur] -= 1;
                dir *= -1;
            }
            cur += dir;
        }
        for(int i = 0; i < n; ++i) {
            if(nums[i] > 0) return false;
        }
        return true;
    }
};
```

Time Complexity : $O(n^2m)$  
Space Complexity : $O(1)$  

```cpp=
class Solution {
public:
    int countValidSelections(vector<int>& nums) {
        int n = nums.size();
        vector<int> prefix(n);
        int res = 0;
        int total = 0;
        for(int i = 0; i < n; ++i) {
            prefix[i] = total;
            total += nums[i];
        }
        for(int i = 0; i < n; ++i) {
            if(nums[i] == 0) {
                // both left and right dir work
                if(prefix[i] == total - prefix[i])
                    res += 2;
                // only the larger dir will work
                else if(abs(total - 2 * prefix[i]) == 1)
                    res += 1;
            }
        }
        return res;
    }
};
```

Time Complexity : $O(n)$  
Space Complexity : $O(n)$  

## 心得  

好累  
