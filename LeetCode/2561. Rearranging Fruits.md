---
tags:
  - LeetCode
---

# [2561. Rearranging Fruits](https://leetcode.com/problems/rearranging-fruits/description/)  

+ 日期 : 2025/08/02  

## 問題描述  

給定兩個整數陣列 `basket1` 和 `basket2`，針對兩個陣列中的元素進行交換，  
使得兩個陣列排序後的元素相同，每次交換的代價為 `min(basket1[i], basket2[j])`，  
其中 `i` 和 `j` 表示要交換的元素所在位置，找出最小的交換代價。  

## 直覺想法  

題目我覺得最重要的話在於 **排序後的元素相同**，  
因為這句話，可以使用 `hash map` 來計算兩個陣列所出現的元素的頻率，  
當某個元素的頻率 `% 2 == 1` 時，表示這個元素無法被完全配對，可以直接回傳 `-1`，  
經過上面的處理後，可以確保兩個陣列的元素可以被完全配對，  
由於是進行次數的計算，因此在 `hash map` 中，不為 `0` 的元素都有一半是要被交換的，  
為了找最小交換代價，我們要盡可能選擇較小的元素進行交換，而我就是死在這，  
交換有兩種情況：

1. `x` 和 `y` 交換，這時候的代價是 `min(x, y)`  
2. `x` 和 `y` 都透過最小元素 `minVal` 交換，這時候的代價是 `minVal * 2`  

因此在交換的時候，我們要考慮兩種情況，選擇較小的一方。  

## 題解  

```cpp=
class Solution {
public:
    long long minCost(vector<int>& basket1, vector<int>& basket2) {
        int m = INT_MAX;
        unordered_map<int, int> frequency_map;
        for (int b1 : basket1) {
            frequency_map[b1]++;
            m = min(m, b1);
        }
        for (int b2 : basket2) {
            frequency_map[b2]--;
            m = min(m, b2);
        }
        vector<int> merge;
        for (auto [k, c] : frequency_map) {
            if (c % 2 != 0) {
                return -1;
            }
            for (int i = 0; i < abs(c) / 2; ++i) {
                merge.push_back(k);
            }
        }
        nth_element(merge.begin(), merge.begin() + merge.size() / 2,
                    merge.end());
        return accumulate(merge.begin(), merge.begin() + merge.size() / 2, 0ll,
                          [&](long long res, int x) -> long long {
                              return res + min(2 * m, x);
                          });
    }
};
```

Time Complexity : $O(nlogn)$  
Space Complexity : $O(n)$  

## 心得  

關於這種數學相關題目我總是想的太複雜，雖然一路過關直到遇到第二種情況的測資，  
但看到後瞬間發覺我的程式碼已經太過複雜，完全沒概念怎麼加入，卻也直接放棄思考，  
看懂答案後才發覺這題好像也就這樣而已，但不會就是不會==
