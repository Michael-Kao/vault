---
tags:
  - LeetCode
---

# [955. Delete Columns to Make Sorted II](https://leetcode.com/problems/delete-columns-to-make-sorted-ii/description/)  

+ 日期 : 2025/12/21  

## 問題描述  

給定一組字串陣列 `strs`，比對每一組字串，若 `strs[i]` 的字典序大於 `strs[i+1]`，則刪除部分欄位，  
使得剩下的字串陣列是有序的，求最少需要刪除多少欄位。  

## 直覺想法  

+ 若 `strs[i][j] < strs[i+1][j]`，則字典序成立  
+ 若 `strs[i][j] == strs[i+1][j]`，則繼續比對下一欄  
+ 若選擇移除某欄位，則需從 `i=0` 開始重新比對  

```
for ex:

["vdy","vei","zvc","zld"]

if column index=1 is deleted (because v>c in "zvc" and "zld" ) , then even though 'vdy'<'vei' ,   
if we delete i=1, it becomes 'vy' and 'vi'. Now y>i ,so the order gets disturbed.   
So we have to again start from i=0 or revert to previous state.
```

1. 建立陣列來存放刪除的欄位  
2. 遍歷 `strs`，查看 `strs[i]` 和 `strs[i-1]` 的各個字元  
3. 若 `strs[i][j] < strs[i-1][j]`，則必須刪除欄位 `j`，並且重製 `i`，從頭開始比對  
4. 若 `strs[i][j] > strs[i-1][j]`，則表示字典序成立，跳出迴圈，繼續比對下一個 `i`  
5. 重複步驟 2~4，直到遍歷完整個 `strs`  

## 題解  

```cpp=
class Solution {
public:
    int minDeletionSize(vector<string>& strs) {
        int n = strs.size();
        int m = strs[0].size();
        vector<bool> skip(n, false);
        int res = 0;
        for(int i = 1; i < n; ++i) {
            for(int j = 0; j < m; ++j) {
                if(skip[j]) continue;
                if(strs[i-1][j] < strs[i][j])   break;
                if(strs[i][j] < strs[i-1][j]) {
                    skip[j] = true;
                    res += 1;
                    i = 0;
                    break;
                }
            }
        }
        return res;
    }
};
```

Time Complexity : $O(nm)$  
Space Complexity : $O(n)$  

## 心得  

其實我一開始一直在想為什麼一遇到不符合就刪除該欄位會是最佳解，  
難到刪除前方所有排序好的欄位不會有更好的結果嗎，我不知道，就算寫完了也還是不知道  
