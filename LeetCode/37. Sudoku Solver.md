---
tags:
  - LeetCode
---

# [37. Sudoku Solver](https://leetcode.com/problems/sudoku-solver/description/)  

+ 日期 : 2025/08/31  

## 問題描述  

給定一個 `9 x 9` 的數獨，寫一個程式來解數獨。  
題目保證有唯一解。  

## 直覺想法  

想法如下：  

1. 找到 `board[i][j] == '.'`，每個格子有 `1~9` 的選擇。  
2. 嘗試塞入 `1~9`，並檢查是否符合數獨規則。  
  + 如果往下解不符合，則回溯後往下找可行的數字。  

本題使用 `Backtracking` 來解。  

## 題解  

```cpp=
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        vector<unordered_set<int>> row(9);
        vector<unordered_set<int>> col(9);
        vector<unordered_set<int>> square(9);
        for(int i = 0; i < 9; ++i) {
            for(int j = 0; j < 9; ++j) {
                if(board[i][j] == '.')
                    continue;
                row[i].insert(board[i][j] - '0');
                col[j].insert(board[i][j] - '0');
                square[i/3*3 + j/3].insert(board[i][j] - '0');
            }
        }

        helper(board, row, col, square, 0, 0);
    }

    bool helper(
        vector<vector<char>> &board,
        vector<unordered_set<int>> &row,
        vector<unordered_set<int>> &col,
        vector<unordered_set<int>> &square,
        int i, int j
    )
    {
        if(i == 8 && j == 9)    return true;
        if(j == 9) {
            i += 1;
            j  = 0;
        }
        if(board[i][j] != '.')
            return helper(board, row, col, square, i, j + 1);
        
        for(int num = 1; num <= 9; ++num) {
            if(
                !row[i].count(num) &&
                !col[j].count(num) &&
                !square[i/3*3 + j/3].count(num)
            )
            {
                board[i][j] = num + '0';
                row[i].insert(num);
                col[j].insert(num);
                square[i/3*3 + j/3].insert(num);
                if(helper(board, row, col, square, i, j+1))
                    return true;
                board[i][j] = '.';
                row[i].erase(num);
                col[j].erase(num);
                square[i/3*3 + j/3].erase(num);
            }
        }
        return false;
    }
};
```

+ m = count of `board[i][j]` == '.'  

Time Complexity : $O(9^m)$  
Space Complexity : $O(9*9)$  

```cpp=
/* check without storing each condition */

class Solution {
public:
    bool isSafe(vector<vector<char>>& board, int row, int col, char dig) {
        // check row
        for (int j = 0; j < 9; j++) {
            if (board[row][j] == dig) return false;
        }

        // check column
        for (int i = 0; i < 9; i++) {
            if (board[i][col] == dig) return false;
        }

        // check 3x3 subgrid
        int sr = (row / 3) * 3;
        int sc = (col / 3) * 3;
        for (int i = sr; i < sr + 3; i++) {
            for (int j = sc; j < sc + 3; j++) {
                if (board[i][j] == dig) return false;
            }
        }
        return true;
    }

    bool helper(vector<vector<char>>& board, int row, int col) {
        if (row == 9) return true; // ✅ solved entire board

        int nextRow = row, nextCol = col + 1;
        if (nextCol == 9) {
            nextRow = row + 1;
            nextCol = 0;
        }

        if (board[row][col] != '.') {
            return helper(board, nextRow, nextCol);
        }

        for (char dig = '1'; dig <= '9'; dig++) {
            if (isSafe(board, row, col, dig)) {
                board[row][col] = dig;
                if (helper(board, nextRow, nextCol)) {
                    return true;
                }
                board[row][col] = '.';
            }
        }
        return false;
    }

    void solveSudoku(vector<vector<char>>& board) {
        helper(board, 0, 0);
    }
};
```

+ m = count of `board[i][j]` == '.'  

Time Complexity : $O(9^m)$  
Space Complexity : $O(1)$  

## 心得  

是說一開始被怎麼 `backtracking` 嚇到了，實際上寫完好像還好。  
