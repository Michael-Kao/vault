---
tags:
  - LeetCode
---

# [756. Pyramid Transition Matrix](https://leetcode.com/problems/pyramid-transition-matrix/description/)  

+ 日期 : 2025/12/29  

## 問題描述  

給定一個字串 `bottom` 和一組字串陣列 `allowed`，`allowed` 由長度為 `3` 的字串組成，  
表示一個金字塔形的結構，即 `allowed[i][0] + allowed[i][1]` 可以堆疊出 `allowed[i][2]`，  
問 `bottom` 是否可以堆疊出頂端的字元。  

## 直覺想法  

1. 先將 `allowed` 轉為一個 `hash map`，key 為 `allowed[i].substr(0, 2)`，value 為 `allowed[i][2]`  
2. 利用 `DFS`，找出下一層的所有可能組合，透過 `queue` 來管理  
3. 如果有 `queue` 中出現長度 `1` 的字串，代表可以堆疊出頂端字元，回傳 `true`  
4. 如果 `queue` 為空，代表無法堆疊出頂端字元，回傳 `false`  

## 題解  

```cpp=
class Solution {
public:
    bool pyramidTransition(string bottom, vector<string>& allowed) {
        unordered_map<string, vector<bool>> mp;
        for(string str : allowed) {
            if(!mp.count(str.substr(0, 2)))
                mp[str.substr(0, 2)] = vector<bool>(6);
            mp[str.substr(0, 2)][str[2] - 'A'] = true;;
        }
        queue<string> nxt;
        unordered_set<string> seen;
        nxt.push(bottom);
        while(!nxt.empty()) {
            string target = nxt.front();
            nxt.pop();
            if(target.size() == 1)  return true;

            string cur = "";
            helper(target, mp, 0, nxt, cur, seen);
        }
        return false;
    }

    void helper(string &str, unordered_map<string, vector<bool>> &mp, int idx, queue<string> &nxt, string &cur, unordered_set<string> &seen) {
        if(idx == str.size() - 1) {
            if(!seen.count(cur)) {
                seen.insert(cur);
                nxt.push(cur);
            }
            return ;
        }

        string base = str.substr(idx, 2);
        for(int i = 0; i < 6; ++i) {
            if(!mp.count(base) || !mp[base][i])    continue;
            char nei = 'A' + i;
            cur += nei;
            helper(str, mp, idx+1, nxt, cur, seen);
            cur.pop_back();
        }
    }
};
```

Time Complexity : $O(A^n)$  
Space Complexity : $O(n^2)$  

## 心得  

剩下兩天就能拿到徽章了...  
