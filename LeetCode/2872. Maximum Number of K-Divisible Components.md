---
tags:
  - LeetCode
---

# [2872. Maximum Number of K-Divisible Components](https://leetcode.com/problems/maximum-number-of-k-divisible-components/description/)  

+ 日期 : 2025/11/28  

## 問題描述  

給定整數 `n` 表示有 `[0, n-1]` 個節點的無向圖，及二維陣列 `edges` 表示圖中的邊，還有一個整數 `k`，  
請將圖分成多個相連元件，每個 `connected component` 的節點總和必須是 `k` 的倍數，  
各節點對應的值為 `values` 陣列中的值，求最多可以分成幾個 `connected component`。  

## 直覺想法  

1. 利用 `DFS` 從子節點開始遍歷  
2. 如果子節點為 `k` 的倍數，表示可以分離，則 `res + 1` 並回傳 `0` (表示該子節點已分離)  
3. 當前節點加上子節點，同樣判斷是否為 `k` 的倍數，若是則分離，否則回傳當前節點的總和  
4. 最後回傳 `res` 即可  

## 題解  

```cpp=
class Solution {
public:
    int maxKDivisibleComponents(int n, vector<vector<int>>& edges, vector<int>& values, int k) {
        vector<vector<int>> adj(n);
        vector<bool> seen(n, false);
        for(int i = 0; i < edges.size(); ++i) {
            int a = edges[i][0];
            int b = edges[i][1];
            
            adj[a].push_back(b);
            adj[b].push_back(a);
        }
        int res = 0;
        dfs(adj, values, k, seen, res, 0);
        return res;
    }

    int dfs(vector<vector<int>> &adj, vector<int> &values, int &k, vector<bool> &seen, int &res, int node) {
        seen[node] = true;
        int cur = values[node] % k;
        for(int nei : adj[node]) {
            if(!seen[nei])
                cur = (cur + dfs(adj, values, k, seen, res, nei)) % k;
        }

        if(cur == 0) {
            res += 1;
        }
        return cur;
    }
};
```

Time Complexity : $O(n)$  
Space Complexity : $O(n)$  

## 心得  

還算簡單吧...  
