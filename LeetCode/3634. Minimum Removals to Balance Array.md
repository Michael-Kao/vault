---
tags:
  - LeetCode
---

# [3634. Minimum Removals to Balance Array](https://leetcode.com/problems/minimum-removals-to-balance-array/description/)  

+ 日期 : 2026/02/06  

## 問題描述  

給定數字陣列 `nums` 和整數 `k`，平衡的陣列表示陣列中 `minimum * k >= maximum`，其中 `minimum` 和 `maximum` 分別是陣列中的最小值和最大值，  
可以對陣列進行任意次數的刪減操作，每次刪減操作可以刪除陣列中的任意一個元素，請返回使陣列平衡所需的最少刪減次數。  

## 直覺想法  

1. 將 `nums` 排序  
2. 遍歷 `nums`，對於每個 `nums[i]`，使用二分搜尋找到第一個 `nums[j]` 使得 `nums[i] * k >= nums[j]`  
3. 計算刪減次數為 `i + (n - j)`，更新最小刪減次數  

## 題解  

```cpp=
class Solution {
public:
    int minRemoval(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        int res = n;
        for(int i = 0; i < n; ++i) {
            int target = (1ll * nums[i] * k >= INT_MAX) ? INT_MAX : nums[i] * k;
            int l = i;
            int r = n-helper(nums, target);
            res = min(res, l+r);
        }
        return (res == n) ? 0 : res;
    }

    int helper(vector<int> &nums, int target) {
        int left = 0;
        int right = nums.size()-1;
        while(left <= right) {
            int mid = (right - left) / 2 + left;
            if(nums[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
};
```

Time Complexity : $O(nlogn)$
Space Complexity : $O(1)$

## 心得  

好累  
