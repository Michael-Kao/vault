---
tags:
  - LeetCode
---

# [3186. Maximum Total Damage With Spell Casting](https://leetcode.com/problems/maximum-total-damage-with-spell-casting/description/)  

+ 日期 : 2025/10/11  

## 問題描述  

給定一個數字陣列 `power`，表示 `index i` 的魔法強度，  
假設今天選擇使用強度為 `power[i]` 的魔法，那麼就不能使用 `power[i]-2, power[i]-1, power[i]+1, power[i]+2` 的魔法，  
問依照規則，能使用的魔法強度總和最大是多少？  

## 直覺想法  

由於 `power[i]+1, power[i]+2` 屬於未來的部分，當我們看到 `index i` 時並不知道其數值，  
因此可控範圍只有到 `index i` 之前的所有部分。  

1. 紀錄所有相同 `power` 的數量，為了方便找出 `power[i]-1, power[i]-2`，紀錄時順便排序  
2. 根據前一步紀錄，我們有 `power[i] -> count` 的資訊，可以計算 `f[j] + power[i] * count[p_i]`  
    + `f[j]` 表示所有 `power[i]-2` 以下的 `power` 總和  
    + 計算完結果為 `f[i]`  
3. 根據前兩個步驟走訪完所有 `power`，即可得到對於 `index i`，其符合題目要求的總和  
4. 走訪第三步尋求最大值  

## 題解  

```cpp=
class Solution {
public:
    long long maximumTotalDamage(vector<int>& power) {
        map<int, int> count;
        for (int p : power) {
            count[p]++;
        }
        vector<pair<int, int>> vec = {{-1e9, 0}};
        for (auto& p : count) {
            vec.push_back(p);
        }
        int n = vec.size();
        vector<long long> f(n, 0);
        long long mx = 0;
        for (int i = 1, j = 1; i < n; i++) {
            while (j < i && vec[j].first < vec[i].first - 2) {
                mx = max(mx, f[j]);
                j++;
            }
            f[i] = mx + 1LL * vec[i].first * vec[i].second;
        }
        long long ans = 0;
        for (int i = 1; i < n; i++) {
            ans = max(ans, f[i]);
        }
        return ans;
    }
};
```

Time Complexity : $O(nlogn)$  
Space Complexity : $O(n)$  

## 心得  

I don't know how to solve dp problem.  
How the fuck can I come up with this?  
Why you only consider the left side of current index?  
