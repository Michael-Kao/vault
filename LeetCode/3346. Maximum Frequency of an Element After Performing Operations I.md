---
tags:
  - LeetCode
---

# [3346. Maximum Frequency of an Element After Performing Operations I](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/description/)  

+ 日期 : 2025/10/21  

## 問題描述  

給定一個數字陣列 `nums` 整數 `k` 和 `numOperations`，可以最多對 `nums` 中的 `numOperations` 個元素進行操作，  
每個操作為該元素可以加上 `[-k, k]` 之間的整數，問進行操作後，陣列中出現的最大頻率的元素的頻率為何？  

## 直覺想法  

1. 對 `nums` 進行排序並計算 `nums` 中每個元素的頻率  
2. 可能被挑選出來的元素為 `[nums[0]-k, nums[n-1]+k]` 之間的整數  
3. 針對可能元素到陣列中查找，利用二分搜，找出 `left` 跟 `right`  
4. 該目標元素的可能頻率為 `right - left + 1`  
5. 由於有 `numOperations` 限制，即最多只能操作 `numOperations` 個元素，那麼 `cnt[target] + numOperations` 為該目標元素可能的最大頻率  
6. 取兩個最小值，即為該目標元素的最大頻率  
7. 更新最終解，直到遍歷完所有可能的目標元素  

## 題解  

```cpp=
class Solution {
public:
    int maxFrequency(vector<int>& nums, int k, int numOperations) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        unordered_map<int, int> cnt;
        for(int num : nums) {
            cnt[num] += 1;
        }
        int res = 0;
        for(int i = nums[0]-k; i <= nums[n-1]+k; ++i) {
            int l = BSL(nums, i, k);
            int r = BSR(nums, i, k);
            int cur = min(r - l + 1, cnt[i] + numOperations);
            res = max(res, cur);
        }
        return res;
    }
    
    int BSL(vector<int> &nums, int target, int k) {
        int left = 0;
        int right = nums.size()-1;
        int res = -1;
        while(left <= right) {
            int mid = (right - left) / 2 + left;
            if(nums[mid] + k >= target) {
                res = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return res;
    }

    int BSR(vector<int> &nums, int target, int k) {
        int left = 0;
        int right = nums.size()-1;
        int res = -1;
        while(left <= right) {
            int mid = (right - left) / 2 + left;
            if(nums[mid] - k <= target) {
                res = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return res;
    }
};
```

Time Complexity : $O(nlogn)$  
Space Complexity : $O(1)$  

## 心得  

二分搜題目都是看到會解，但自己想不到==  
