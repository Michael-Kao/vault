---
tags:
  - LeetCode
---

# [474. Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/description/)  

+ æ—¥æœŸ : 2025/11/11  

## å•é¡Œæè¿°  

çµ¦å®šä¸€å€‹å­—ä¸²é™£åˆ— `strs`ï¼Œå…§éƒ¨ç”± `0` å’Œ `1` çµ„æˆçš„å­—ä¸²ï¼Œé‚„æœ‰å…©å€‹æ•´æ•¸ `m` å’Œ `n`ï¼Œ  
é¡Œç›®è¦æ±‚æˆ‘å€‘é¸æ“‡é™£åˆ—ä¸­çš„å­—ä¸²ï¼Œè¨ˆç®—å…¶ `0` å’Œ `1` çš„æ•¸é‡ï¼Œ  
å•åœ¨ `0` çš„æ•¸é‡ä¸è¶…é `m`ï¼Œä¸” `1` çš„æ•¸é‡ä¸è¶…é `n` çš„æ¢ä»¶ä¸‹ï¼Œ  
èƒ½å¤ é¸æ“‡çš„å­—ä¸²çš„æœ€å¤§æ•¸é‡æ˜¯å¤šå°‘ã€‚  

## ç›´è¦ºæƒ³æ³•  

1. è¨ˆç®—æ‰€æœ‰å­—ä¸²çš„ `0` å’Œ `1` æ•¸é‡  
2. å°æ–¼æ¯ä¸€å€‹å­—ä¸²ï¼Œå¯ä»¥é¸æˆ–è€…ä¸é¸ï¼Œå› æ­¤å¯«ä¸€å€‹ `helper`  
3. åœ¨ `helper` ä¸­ï¼Œç´€éŒ„å¦‚æœé¸æ“‡ï¼Œç›®å‰çš„ `0` å’Œ `1` æ˜¯å¤šå°‘ï¼Œä»¥åŠç›®å‰é¸æ“‡äº†å¤šå°‘å­—ä¸²  
4. å¦‚æœè¶…é `m` æˆ– `n`ï¼Œå°±ä¸ç¹¼çºŒå¾€ä¸‹èµ°  
5. å¦‚æœç›®å‰å…ƒç´ å¯ä»¥é¸æ“‡ï¼Œå‰‡åˆ†æˆå…©æ¢è·¯å¾‘ï¼Œä¸€æ¢é¸æ“‡è©²å­—ä¸²ï¼Œä¸€æ¢ä¸é¸æ“‡è©²å­—ä¸²  
6. å¾å…©æ¢è·¯å¾‘ä¸­ï¼Œå–æœ€å¤§å€¼å›å‚³  

+ [Tutorial](https://leetcode.com/problems/ones-and-zeroes/solutions/814077/dedicated-to-beginners-by-rohanprakash-0nv7)  

## é¡Œè§£  

```cpp=
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int size = strs.size();
        vector<vector<int>> cnt(size, vector<int>(2, 0));
        for(int i = 0; i < size; ++i) {
            for(char c : strs[i]) {
                cnt[i][c - '0'] += 1;
            }
        }

        vector<vector<vector<int>>> dp(size, vector<vector<int>>(m+1, vector<int>(n+1, -1)));
        int res = helper(cnt, {m, n}, 0, dp);
        return res;
    }

    int helper(vector<vector<int>> &cnt, vector<int> remain, int idx, 
        vector<vector<vector<int>>> &dp) {
        if(idx == cnt.size() || (remain[0] == 0 && remain[1] == 0))
            return 0;
        
        if(dp[idx][remain[0]][remain[1]] != -1)
            return dp[idx][remain[0]][remain[1]];
        
        // we can only skip this
        if(cnt[idx][0] > remain[0] || cnt[idx][1] > remain[1]) {
            return dp[idx][remain[0]][remain[1]] = helper(cnt, remain, idx+1, dp);
        }

        remain[0] -= cnt[idx][0];
        remain[1] -= cnt[idx][1];
        int nskip = 1 + helper(cnt, remain, idx+1, dp);
        remain[0] += cnt[idx][0];
        remain[1] += cnt[idx][1];
        int skip = helper(cnt, remain, idx+1, dp);

        return dp[idx][remain[0]][remain[1]] = max(skip, nskip);
    }
};
```

Time Complexity : $O(Lmn)$  
Space Complexity : $O(Lmn)$  

## å¿ƒå¾—  

I know nothing about DP ğŸ˜­  
