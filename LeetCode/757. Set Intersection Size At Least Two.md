---
tags:
  - LeetCode
---

# [757. Set Intersection Size At Least Two](https://leetcode.com/problems/set-intersection-size-at-least-two/description/)  

+ 日期 : 2025/11/20  

## 問題描述  

給定一個二維陣列 `intervals`，建立一個 `res` 陣列，陣列中的數字必須滿足:  

+ 對於每一個 `intervals[i]`，都有至少兩個數字在 `res` 中同時出現。  

回傳 `res` 陣列的最小長度。  

## 直覺想法  

1. 將 `intervals` 由小到大排序  
2. 紀錄前一個區間選擇的值，由於要選擇盡量跨過多個區間的值，因此選擇該區間的最大值與次大值  
3. 判斷目前區間的起始是否大於前次選擇的最大值:  
    + 是: 代表沒有交集，需新增兩個數字，選擇目前區間的最大值與次大值  
    + 否: 判斷目前區間的起始是否大於前次選擇的次大值:  
        - 是: 代表有一個交集，需新增一個數字，選擇目前區間的最大值  
        - 否: 代表有兩個交集，不需新增數字，更新前次選擇的最大值與次大值為目前區間的最大值與次大值

## 題解  

```cpp=
class cmp {
public:
    bool operator()(vector<int> &a, vector<int> &b) {
        if(a[1] == b[1])
            return a[0] < b[0];
        return a[1] < b[1];
    }
};
class Solution {
public:
    int intersectionSizeTwo(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), cmp());
        int res = 0;
        vector<int> pre;
        for(int i = 0; i < intervals.size(); ++i) {
            if(pre.empty()) {
                pre.push_back(intervals[i][1]-1);
                pre.push_back(intervals[i][1]);
                res += 2;
            } else if(intervals[i][0] > pre[1]) {
                pre[0] = intervals[i][1]-1;
                pre[1] = intervals[i][1];
                res += 2;
            } else if(pre[0] < intervals[i][0]) {
                if(pre[1] == intervals[i][1])
                    pre[0] = pre[1]-1;
                else
                    pre[0] = pre[1];
                pre[1] = intervals[i][1];
                res += 1;
            }
        }
        return res;
    }
};
```

Time Complexity : $O(nlogn)$  
Space Complexity : $O(1)$  

## 心得  

`Greedy` 好討厭阿，有想法就會，沒想法卡死，每次都把自己想死了  
