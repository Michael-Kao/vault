---
tags:
  - LeetCode
---

# [2438. Range Product Queries of Powers](https://leetcode.com/problems/range-product-queries-of-powers/description/)  

+ 日期 : 2025/08/11  

## 問題描述  

給定一個數字 `n` 和一個二維陣列 `queries`，先建立一個 $2^k$ 的陣列 `powers`，  
其中 `powers` 的總和為 `n`，找出陣列後根據 `queries[i] = [left, right]`，  
求出長度同為 `queries` 的陣列 `answers`，其中 `answers[i]` 為 `powers[left] * powers[left + 1] * ... * powers[right]` 的值。  

## 直覺想法  

因為 `n` 為 `INT`，所以可以從 `[0, 31]` 開始求出 `powers` 的值，  
只要 `n & (1 << i)` 為 `1`，則加入到 `powers` 中，  
有了 `powers` 之後，對於每個 `queries[i]`，  
可以直接計算 `answers[i]` 的值。  

## 題解  

```cpp=
class Solution {
public:
    vector<int> productQueries(int n, vector<vector<int>>& queries) {
        int MOD = 1e9 + 7;
        vector<int> powers;
        for(int i = 0; i < 32; ++i) {
            if(n < (1 << i))
                break;
            if(n & (1 << i))
                powers.push_back(1 << i);
        }
        int size = queries.size();
        vector<int> res(size, 0);
        for(int i = 0; i < size; ++i) {
            int l = queries[i][0];
            int r = queries[i][1];
            int val = 1;
            while(l <= r) {
                val = (1ll * val * powers[l]) % MOD;
                l += 1;
            }
            res[i] = val;
        }
        return res;
    }
};
```

Time Complexity : $O(logn + size*len)$  
Space Complexity : $O(32)$  

## 心得  

題目很難懂，但問題很簡單，記得處理 `MOD` 的問題就好。  
