---
tags:
  - LeetCode
---

# [2435. Paths in Matrix Whose Sum Is Divisible by K](https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/description/)  

+ 日期 : 2025/11/26  

## 問題描述  

給定一個 `m x n` 的矩陣 `grid` 和一個整數 `k`，你從矩陣 `(0, 0)` 為起點，  
每次可以走向右或向下兩個方向，直到走到終點 `(m-1, n-1)` 的位置，  
將路線上所有數字相加，如果總和能被 `k` 整除，則 `res + 1`，請問有多少條這樣的路線？  

## 直覺想法  

1. 使用 `BFS` 或 `DFS` 模擬所有路徑  
2. 由於可能造成總和過大，使用 `sum % k` 來記錄目前的餘數狀態  
3. 使用三維陣列 `memo[r][c][sum % k]` 來紀錄目前位置 `(r, c)` 以及餘數 `sum % k` 的路徑數量  
4. 初始位置 `memo[0][0][grid[0][0] % k] = 1`  

## 題解  

```cpp=
class Solution {
public:
    int MOD = 1e9 + 7;
    int m, n;
    vector<vector<int>> dir = {
        {0, 1},
        {1, 0}
    };

    int numberOfPaths(vector<vector<int>>& grid, int k) {
        m = grid.size();
        n = grid[0].size();
        vector<vector<vector<int>>> memo(m, vector<vector<int>>(n, vector<int>(k)));

        return dfs(grid, 0, 0, grid[0][0]%k, memo, k);
    }

    int dfs(vector<vector<int>> &grid, int r, int c, 
        int cur, vector<vector<vector<int>>> &memo, int &k) {
        if(r == m-1 && c == n-1) {
            if(cur == 0)
                return 1;
            else
                return 0;
        }
        if(memo[r][c][cur] != 0)
            return memo[r][c][cur];
        
        for(int i = 0; i < 2; ++i) {
            int nr = r + dir[i][0];
            int nc = c + dir[i][1];

            if(nr == m || nc == n)
                continue;
            
            int nxt = (cur + grid[nr][nc]) % k;
            memo[r][c][cur] = (memo[r][c][cur] + dfs(grid, nr, nc, nxt, memo, k)) % MOD;
        }
        return memo[r][c][cur];
    }
};
```

Time Complexity : $O(mnk)$  
Space Complexity : $O(mnk)$  

```cpp=
typedef long long ll;
const int MOD = 1e9 + 7;

class Solution {
public:
    int numberOfPaths(vector<vector<int>>& grid, int k) {
        int m = grid.size();
        int n = grid[0].size();

        auto dp = vector(m + 1, vector(n + 1, vector<ll>(k)));

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (i == 1 && j == 1) {
                    dp[i][j][grid[0][0] % k] = 1;
                    continue;
                }

                int value = grid[i - 1][j - 1] % k;
                for (int r = 0; r < k; r++) {
                    int prevMod = (r - value + k) % k;
                    dp[i][j][r] =
                        (dp[i - 1][j][prevMod] + dp[i][j - 1][prevMod]) % MOD;
                }
            }
        }

        return dp[m][n][0];
    }
};
```

Time Complexity : $O(mnk)$  
Space Complexity : $O(mnk)$  

## 心得  

我不會用 `BFS` 的時候加上 `memo` ==  
所以我又改成 `DFS`，總體來說應該不難，但我基礎 `DP` 太爛了  
